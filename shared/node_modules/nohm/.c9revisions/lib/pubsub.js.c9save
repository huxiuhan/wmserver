{"ts":1341349210187,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var Nohm = null;\n\nexports.setNohm = function (originalNohm) {\n  Nohm = originalNohm;\n  initialize();\n};\n\nvar EventEmitter = require('events').EventEmitter;\nvar h = require(__dirname + '/helpers');\n\n\n/**\n * Seperate redis client for pubSub.\n */\nvar pub_sub_client = false;\n\nvar pub_sub_all_pattern = false;\n\nvar pub_sub_event_emitter = false;\n\nvar do_publish = false;\n\nvar is_subscribed = false;\n\n/**\n *  Publish something on the nohm client.\n */\nvar publish = function (channel, payload, parse) {\n  var message;\n  var client = Nohm.client;\n\n  if (parse || typeof payload !== 'string') {\n    message = JSON.stringify(payload);\n  }\n\n  if (!client) {\n    Nohm.logError(\"No redis client specified. Please provide one (Nohm.setClient()).\");\n  } else if (!client.publish) {\n    Nohm.logError(\"Specified client does not support pubsub.\");\n  } else {\n    client.publish( Nohm.prefix.channel + channel, message );\n  }\n};\n\nvar initializePubSub = function initializePubSub (callback) {\n    \n  if (!pub_sub_client) {\n    return Nohm.logError('A second redis client must be specified to use pub/sub methods. Please declare one.');\n  } else if (is_subscribed === true) {\n    // already in pubsub mode, don't need to initialize it again.\n    if (typeof(callback) === 'function') {\n      callback();\n    }\n    return;\n  }\n  \n  is_subscribed = true;\n  \n  pub_sub_all_pattern = Nohm.prefix.channel + '*:*';\n  pub_sub_event_emitter = new EventEmitter();\n  pub_sub_event_emitter.setMaxListeners(0);\n\n  pub_sub_client.psubscribe(pub_sub_all_pattern, callback);\n\n  pub_sub_client.on('pmessage', function(pattern, channel, message){\n    var modelName;\n    var action;\n    var payload;\n    var suffix = channel.slice(Nohm.prefix.channel.length);\n    var parts = suffix.match(/([^:]+)/g); // Pattern = _prefix_:channel:_modelname_:_action_\n\n    if (!parts) {\n      Nohm.logError(\"An erroneous channel has been captured.\");\n      return;\n    }\n\n    modelName = parts[0];\n    action = parts[1];\n\n    payload = {};\n\n    try {\n      payload = message ? JSON.parse(message) : {};\n    } catch (e) {\n      Nohm.logError('A published message is not valid JSON. Was : \"'+message+'\"');\n      return;\n    }\n  \n    pub_sub_event_emitter.emit(modelName+':'+action, payload);\n    //pub_sub_event_emitter.emit(modelName+':all', action, payload);\n\n  });\n};\n\nvar initialize = function () {\n\n  /**\n   * Set the pubSub client and initialize the subscriptions and event emitters.\n   * \n   * @param {Object} client Redis client to use. This client will be set to pubSub and cannot be used for normal commands after that.\n   * @param {Function} callback Called after the provided redis client is subscribed to the necessary channels.\n   */\n  Nohm.setPubSubClient = function (client, callback) {\n    pub_sub_client = client;\n    Nohm.closePubSub(function () {\n      initializePubSub(callback);\n    });\n  };\n\n  /**\n   * Return the PubSub Client, if set.\n   */\n  Nohm.getPubSubClient = function () {\n    return pub_sub_client;\n  };\n\n  /**\n   * Unsubscribes from the nohm redis pubsub channel.\n   * \n   * @param {Function} callback Called after the unsubscibe. Parameters: redisClient\n   */\n  Nohm.closePubSub = function closePubSub (callback) {\n    if (is_subscribed === true) {\n      is_subscribed = false;\n      pub_sub_client.punsubscribe(pub_sub_all_pattern, function () {\n        callback(null, pub_sub_client);\n      });\n    } else {\n      callback(null, pub_sub_client);\n    }\n  };\n\n \n\n  var messageComposers = {\n\n    // The default (base) message creator\n    defaultComposer: function defaultComposer (action) {\n      return {\n        target: {\n          id: this.id,\n          modelName: this.modelName,\n          properties: this.allProperties()\n        }\n      };\n    }\n\n  };\n\n  // This populates the diff property for `save` and `update` events.\n  messageComposers.save = messageComposers.update = function changeComposer (action, diff) {\n    var result = messageComposers.defaultComposer.apply(this, arguments);\n    result.target.diff = diff;\n    return result;\n  };\n\n  // This sets the id and properties\n  messageComposers.remove = function removeComposer (action, id) {\n    var result = messageComposers.defaultComposer.apply(this, arguments);\n    result.target.id = id;\n    return result;\n  };\n\n  messageComposers.link = messageComposers.unlink = function relationComposer (action, parent, relationName) {\n    var result = {};\n    result.child = messageComposers.defaultComposer.call(this, action).target;\n    result.parent = messageComposers.defaultComposer.call(parent, action).target;\n    result.relation = relationName;\n    return result;\n  };\n\n\n  var supportedActions = [ 'create', 'update', 'save', 'remove', 'unlink', 'link' ];\n  \n  /**\n   * Fires an event to be published to the redis db by the internal publisher.\n   * \n   * @param {String} event Name of the event to be published. Allowed are: [ 'create', 'update', 'save', 'remove', 'unlink', 'link' ]\n   */\n  Nohm.prototype.fireEvent = function (event) {\n    var channel;\n    var composer;\n    var payload;\n    var supported;\n    \n    if ( ! this.getPublish() ) {\n      // global or model specific setting for publishing events is false.\n      return false;\n    }\n\n    if (supportedActions.indexOf(event) < 0) {\n      supported = supportedActions.join(', ');\n      Nohm.logError(\n        'Cannot fire an unsupported action. Was \"' + event + '\" ' +\n        'and must be one of ' + supported\n        );\n      return false;\n    }\n\n    channel = this.modelName + ':' + event;\n    composer = messageComposers[event] || messageComposers.defaultComposer;\n\n    payload = composer.apply(this, arguments);\n    publish(channel, payload);\n  };  \n  \n  /**\n   * Set global boolean to publish events or not.\n   * By default publishing is disabled globally.\n   * The model-specific setting overwrites the global setting.\n   * \n   * @param {Boolean} publish Whether nohm should publish its events.\n   */\n  Nohm.setPublish = function (publish) {\n    do_publish = !!publish;\n  }\n  \n  /**\n   * Get the model-specific status of whether event should be published or not.\n   * If no model-specific setting is found, the global setting is returned.\n   * \n   * @returns {Boolean} True if this model will publish its events, False if not.\n   */\n  Nohm.prototype.getPublish = function () {\n    if (this.hasOwnProperty('publish')) {\n      return !!this.publish;\n    }\n    return do_publish;\n  };\n\n  /**\n   * Subscribe to events of nohm models.\n   * \n   * @param {String} event_name Name of the event to be listened to. Allowed are: [ 'create', 'update', 'save', 'remove', 'unlink', 'link' ]\n   * @param {Function} callback Called every time an event of the provided name is published on this model.\n   */\n  Nohm.prototype.subscribe = function (event_name, callback) {\n    var self = this;\n    initializePubSub(function () {\n      pub_sub_event_emitter.on(self.modelName+':'+event_name, callback);\n    });\n  };\n\n\n  /**\n   * Subscribe to an event of nohm models only once.\n   * \n   * @param {String} event_name Name of the event to be listened to. Allowed are: [ 'create', 'update', 'save', 'remove', 'unlink', 'link' ]\n   * @param {Function} callback Called once when an event of the provided name is published on this model and then never again.\n   */\n  Nohm.prototype.subscribeOnce = function (event_name, callback) {\n    var self = this;\n    initializePubSub(function () {\n      pub_sub_event_emitter.once(self.modelName+':'+event_name, callback);\n    });\n  };\n\n  /**\n   * Unsubscribe from a nohm model event.\n   * \n   * @param {String} event_name Name of the event to be unsubscribed from. Allowed are: [ 'create', 'update', 'save', 'remove', 'unlink', 'link' ]\n   * @param {Function} fn Function to unsubscribe. If none is provided all subscriptions of the given event are unsubscribed!\n   */\n  Nohm.prototype.unsubscribe = function (event_name, fn) {\n    if (pub_sub_event_emitter !== false) {\n      if (! fn) {\n        pub_sub_event_emitter.removeAllListeners(self.modelName+':'+event_name);\n      } else {\n        pub_sub_event_emitter.removeListener(self.modelName+':'+event_name, fn);\n      }\n    }\n  };\n\n};\n\n"]],"start1":0,"start2":0,"length1":0,"length2":8118}]],"length":8118}
