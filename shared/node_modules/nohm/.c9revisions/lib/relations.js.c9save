{"ts":1342147971262,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var Nohm = null;\nexports.setNohm = function (originalNohm) {\n  Nohm = originalNohm;\n};\n\nvar async = require('async');\nvar h = require(__dirname + '/helpers');\n\n/**\n * Check if the object has a relation to another object.\n */\nexports.belongsTo = function belongsTo(obj, name) {\n  var callback = h.getCallback(arguments),\n      self = this;\n  name = name && typeof name !== 'function' ? name : 'default';\n  if (!this.id || !obj.id) {\n    Nohm.logError('Calling belongsTo() even though either the object itself or the relation does not have an id.');\n  }\n  this.getClient().sismember(this.relationKey(obj.modelName, name),\n                  obj.id,\n                  function (err, value) {\n                    if (err) {\n                      this.logError(err);\n                    }\n                    callback.call(self, err, !!value);\n                  });\n};\n\n/**\n * Returns the key needed for getting related objects\n */\nexports.relationKey = function relationKey(objName, name) {\n  return Nohm.prefix.relations + this.modelName + ':' + name + ':' + objName +\n    ':' + this.id;\n};\n\n/**\n * Retrieves all relations to another model.\n */\nexports.getAll = function getAll(objName, name) {\n  var callback = h.getCallback(arguments),\n  self = this;\n  name = name && typeof name !== 'function' ? name : 'default';\n  if (!this.id) {\n    Nohm.logError('Calling getAll() even though this '+this.modelName+' has no id. Please load or save it first.');\n  }\n  this.getClient().smembers(this.relationKey(objName, name),\n                  function (err, value) {\n                    if (err) {\n                      self.logError(err);\n                    }\n                    if (!Array.isArray(value)) {\n                      value = [];\n                    } else {\n                      value = value.map(function (val) {\n                        if (self.idGenerator === 'increment') {\n                          val = parseInt(val.toString(), 10);\n                        }\n                        return val;\n                      });\n                    }\n                    callback.call(self, err, value);\n                  });\n};\n\n/**\n *  Returns the number of links of a specified relation (or the default) an instance has to models of a given modelName.\n * \n *  @param {String} obj_name Name of the model on the other end of the relation.\n *  @param {String} [relation_name=\"default\"] Name of the relation\n *  @param {Function} callback Callback called with (err, num_relations\n */\nexports.numLinks = function numLinks(obj_name, relation_name, callback) {\n  callback = h.getCallback(arguments);\n  var self = this;\n  relation_name = relation_name && typeof relation_name !== 'function' ? relation_name : 'default';\n  if (!this.id) {\n    Nohm.logError('Calling numLinks() even though either the object itself or the relation does not have an id.');\n  }\n  this.getClient().scard(this.relationKey(obj_name, relation_name),\n                  function (err, num_relations) {\n                    if (err) {\n                      self.logError(err);\n                    }\n                    callback.call(self, err, num_relations);\n                  });\n};\n\nvar allowedLinkTypes = ['sadd', 'srem'];\n\nexports.__linkProxied = function __linkProxied(type, obj, options, callback) {\n  \n  options = typeof(options) === 'object' && Object.keys(options).length > 0 ? options : {};\n  callback = h.getCallback(arguments);\n\n  var self = this,\n  foreignName = options.name + 'Foreign',\n  silent = !!options.silent,\n  client = self.getClient(),\n  redisExec = function (cb) {\n    var dbVals = [{\n        key: self.relationKey(obj.modelName, options.name), \n        keyStore: self.modelName+':'+self.id,\n        id: obj.id\n      }, {\n        key: obj.relationKey(self.modelName, foreignName),\n        keyStore: obj.modelName+':'+obj.id,\n        id: self.id\n      }\n    ];\n\n    async.forEach(dbVals, \n      function (val, next) {\n        var multi = client.multi();\n        multi[type](Nohm.prefix.relationKeys+val.keyStore, val.key);\n        multi[type](val.key, val.id);\n        multi.exec(next);\n      }, \n      function (err) {\n        if (!silent && !err) {\n          self.fireEvent( type === 'sadd' ? 'link' : 'unlink', obj, options.name );\n        }\n        if (err && typeof(options.error) === 'function') {\n          options.error(err, 'Linking failed.', obj);\n        }\n        cb.call(self, err);\n      }\n    );\n  };\n  \n  if (allowedLinkTypes.indexOf(type) === -1) {\n    callback.call(self, 'wrong link/unlink type invocation');\n  } else if (!this.id) {\n    callback.call(self, 'You need to save an object before adding a link. (this might be a nohm error)');\n  } else if (!obj.id) {\n    obj.save(options, function (err, link_error, link_name) {\n      if (err && !link_error && typeof(options.error) === 'function') {\n        options.error(err, obj.errors, obj);\n      }\n      if (err) {\n        callback(err, link_error, link_name);\n      } else {\n        redisExec(callback);\n      }\n    });\n  } else {\n    redisExec(callback);\n  }\n};\n\nexports.__link = function __link(obj, options, cb) {\n  this.__linkProxied('sadd', obj, options, cb);\n};\n\nexports.__unlink = function __unlink(obj, options, cb) {\n  this.__linkProxied('srem', obj, options, cb);\n};\n\n/**\n *  Adds a reference to another object.\n */\nexports.link = function link(obj, options, callback) {\n\n  if (typeof(options) === 'string') {\n    options = {name: options};\n  }\n  var opts = h.$extend({\n    name: 'default'\n  }, options);\n\n  callback = h.getCallback(arguments);\n  \n  this.relationChanges.push({\n    action: 'link',\n    object: obj,\n    options: opts,\n    callback: callback\n  });\n};\n\n/**\n *  Removes the reference in the current object to\n *  the object given in the first argument.\n *  Note: this leaves the given object itself intact.\n */\nexports.unlink = function unlink(obj, options, callback) {\n\n  if (typeof(options) === 'string') {\n    options = {name: options};\n  }\n  var opts = h.$extend({\n    name: 'default'\n  }, options);\n\n  callback = h.getCallback(arguments);\n  \n  var changes = this.relationChanges;\n  for (var i in changes) {\n    if (changes.hasOwnProperty(i) &&\n        changes[i].name === opts.name &&\n        h.checkEqual(changes[i].object, obj)) {\n      delete this.relationChanges[i];\n    }\n  }\n  \n  this.relationChanges.push({\n    action: 'unlink',\n    options: opts,\n    callback: callback,\n    object: obj\n  });\n};\n\n/**\n * Removes all links to all other object instances\n */\nexports.unlinkAll = function (client, callback) {\n  var self = this;\n  var normalClient = this.getClient();\n  var relationKeys_key = Nohm.prefix.relationKeys+this.modelName+':'+this.id;\n  client = client || normalClient;\n\n  this.relationChanges = [];\n\n  // we usenormalClient for fetching data and client (which could be a provided client in multi mode) for manipulating data\n  normalClient.smembers(relationKeys_key, function (err, keys) {\n    var others = [];\n    keys.forEach(function (key) {\n      var matches = key.match(/:([\\w]*):([\\w]*):[\\w]+$/i);\n      var selfName = matches[1];\n      var otherName;\n      var namedMatches;\n      if (matches[1] === 'default') {\n        otherName = 'defaultForeign';\n      } else if (matches[1] === 'defaultForeign') {\n        otherName = 'default';\n      } else {\n        namedMatches = matches[1].match(/^([\\w]*)Foreign$/);\n        if (namedMatches) {\n          selfName = matches[1];\n          otherName = namedMatches[1];\n        } else {\n          selfName = matches[1];\n          otherName = matches[1] + 'Foreign';\n        }\n      }\n      others.push({\n        model: matches[2],\n        selfName: selfName,\n        otherName: otherName\n      });\n    });\n    async.map(others, function (item, cb) {\n      normalClient.smembers(\n        Nohm.prefix.relations+self.modelName+':'+item.selfName+':'+item.model+':'+self.id,\n        function (err, ids) {\n          if (err) {\n            Nohm.logError(err);\n          }\n          ids.forEach(function (id) {\n            client.srem(Nohm.prefix.relations+item.model+':'+item.otherName+':'+self.modelName+':'+id, self.id);\n          });\n          cb(err, Nohm.prefix.relations+self.modelName+':'+item.selfName+':'+item.model+':'+self.id);\n        }\n      );\n    }, function (err, links) {\n      if (links.length > 0) {\n        links.push(relationKeys_key);\n        links.push(function (err) {\n          if (err) {\n            Nohm.logError('There was a problem while deleting keys:'+err);\n          }\n        });\n        client.del.apply(client, links);\n      }\n      callback.call(self, err);\n    });\n  });\n};\n\n"]],"start1":0,"start2":0,"length1":0,"length2":8562}]],"length":8562}
{"ts":1354637811735,"patch":[[{"diffs":[[0,"    "],[-1,"if (self.idGenerator === 'increment'"],[1,"var int_val = parseInt(val.toString(), 10);\n                        if (!isNaN(int_val)"],[0,") {\n"]],"start1":1838,"start2":1838,"length1":44,"length2":95},{"diffs":[[0,"l = "],[-1,"parseInt("],[1,"int_"],[0,"val"],[-1,".toString(), 10)"],[0,";\n  "]],"start1":1961,"start2":1961,"length1":36,"length2":15}]],"length":8592,"saved":false}
{"ts":1354637898767,"patch":[[{"diffs":[[0,"int_val)"],[1," && int_val == val"],[0,") {\n    "]],"start1":1921,"start2":1921,"length1":16,"length2":34}]],"length":8610,"saved":false}
{"ts":1354638074045,"patch":[[{"diffs":[[0,"    "],[-1,"var int_val = parseInt(val.toString(), 10);\n                        if (!isNaN(int_val) && int_val == val"],[1,"if (self.idGenerator === 'increment'"],[0,") {\n"]],"start1":1838,"start2":1838,"length1":113,"length2":44},{"diffs":[[0,"l = "],[-1,"int_"],[1,"parseInt("],[0,"val"],[1,".toString(), 10)"],[0,";\n  "]],"start1":1910,"start2":1910,"length1":15,"length2":36}]],"length":8562,"saved":false}
{"ts":1354638111099,"patch":[[{"diffs":[[0,"    "],[-1,"if (self.idGenerator === 'increment'"],[1,"var int_val = parseInt(val.toString(), 10);\n                        if (!isNaN(int_val) && int_val == val"],[0,") {\n"]],"start1":1838,"start2":1838,"length1":44,"length2":113},{"diffs":[[0,"l = "],[-1,"parseInt("],[1,"int_"],[0,"val"],[-1,".toString(), 10)"],[0,";\n  "]],"start1":1979,"start2":1979,"length1":36,"length2":15}]],"length":8610,"saved":false}
