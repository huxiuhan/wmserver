{"ts":1342885449825,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var Nohm = null;\nexports.setNohm = function (originalNohm) {\n  Nohm = originalNohm;\n  Nohm.__validators = validators;\n};\n\nvar async = require('async');\nvar util = require('util');\nvar h = require(__dirname + '/helpers');\nvar validators = require(__dirname + '/validators').validators;\n\n/**\n *  Check if one or all propert(y/ies) are valid.\n * @see Validators\n */\nexports.valid = function valid(key, setDirectly) {\n  var p;\n  var self = this;\n  var noKeySpecified = !key || typeof(key) === 'function';\n  var callback = h.getCallback(arguments);\n  var parallel =  [];\n  key = typeof(key) === 'string' ? key : false;\n  setDirectly = typeof(setDirectly) === 'boolean' ? setDirectly : false;\n  \n  for (p in this.properties) {\n    if (noKeySpecified || key === p) {\n      parallel = parallel.concat(this.__validateProperty(p));\n    }\n  }\n  async.parallel(parallel, function (error, results) {\n    var validbool = results.indexOf(false) === -1;\n    if (error) {\n      Nohm.logError('Some validation caused an error');\n    }\n    \n    if ( ! validbool) {\n      // if others failed we must not set unique locks directly\n      setDirectly = false;\n    }\n    \n    self.__checkUniques(setDirectly, function (success) {\n  \n      if ( ! success) {\n        validbool = false;\n      }\n      callback(validbool);\n    }, key);\n  });\n};\n\n/**\n *  Check whether all properties marked as unique have a value that is not set in the database yet.\n *  If setDirectly is set, it will occupy the unique in the db directly.\n *  Use setDirectly if you're saving the object to prevent race-conditions.\n */\nexports.__checkUniques = function __checkUniques(setDirectly, saveCallback, p) {\n  setDirectly = setDirectly || false;\n  var tmp = this.properties,\n  self = this,\n  tmpUniques = [],\n  success = true,\n  client = self.getClient(),\n  uniqueLocker = function uniqueLocker(propName, callback) {\n    if (tmp[propName].unique && // is marked as unique\n      (!p || propName === p) && // if all props are to be checked or the current one matches the 1\n      tmp[propName].value !== '' &&\n      (tmp[propName].__updated || !self.__inDB)) {\n      var propLower = tmp[propName].type === 'string' ? self.p(propName).toLowerCase() : self.p(propName);\n      var unique_key = Nohm.prefix.unique + self.modelName + ':' + propName + ':' + propLower;\n      var checkCallback = function (err, value) {\n        if (setDirectly && value) {\n          tmpUniques.push(unique_key);\n        }\n        if (!setDirectly) {\n          // client.exists returns 1 if the value exists, client.setnx returns 1 if the value did not exist.\n          // what we pass to the callback is whether the property has a unique value or if it already exists.\n          // that means if we used exists we have to use the opposite of the returned value.\n          value = !value;\n        }\n        callback(err, {\n          p: propName,\n          unique: value\n        });\n      };\n      \n      if (setDirectly) {\n        /*\n         * We lock the unique value here if it's not locked yet, then later remove the old uniquelock when really saving it. (or we free the unique slot if we're not saving)\n         */\n        client.setnx(unique_key, self.id, checkCallback);\n      } else {\n        client.exists(unique_key, checkCallback);\n      }\n    } else {\n      callback(null, null);\n    }\n  };\n  if (setDirectly && !self.id) {\n    Nohm.logError('Checking AND setting uniques without having an id set. self:' + require('util').inspect(self));\n  }\n  \n  async.map(Object.keys(tmp), uniqueLocker, function (err, arr) {\n    if (Array.isArray(arr) && arr.length > 0) {\n      arr.forEach(function(val) {\n        if (val && ! val.unique) {\n          self.errors[val.p].push('notUnique');\n          success = false;\n        }\n      });\n    }\n    \n    if (setDirectly && ! success) {\n      if (Array.isArray(tmpUniques) && tmpUniques.length > 0) {\n        tmpUniques.forEach(function(val) {\n          // delete tmp unique locks since the new values won't be saved.\n          client.del(val, self.logError);\n        });\n      }\n    }\n    saveCallback(success);\n  });\n};\n\n/**\n *  Set the real id of the unique values.\n */\nexports.__setUniqueIds = function __setUniqueIds(id, cb) {\n  var p,\n  args = [];\n  for (p in this.properties) {\n    if (this.properties.hasOwnProperty(p) && this.properties[p].unique &&\n      this.properties[p].value !== '' &&\n      (this.properties[p].__updated || !this.__inDB)) {\n        var val = this.properties[p].type === 'string' ? this.p(p).toLowerCase() : this.p(p);\n        args.push(Nohm.prefix.unique + this.modelName + ':' + p + ':' + val);\n        args.push(id);\n    }\n  }\n  \n  if (args.length > 0) {\n    this.getClient().mset(args, cb);\n  } else {\n    cb();\n  }\n};\n\n/**\n * Returns an array of functions that validate a given property.\n * \n * Important: Any changes here should proably be done in validators.js for the browser validation functions as well!\n */\nexports.__validateProperty = function __validateProperty(p) {\n  if (!p || !this.properties[p]) {\n    nohm.logError('Trying to validate undefined property or accessing __validateProperty without giving a property');\n  }\n  if (!this.properties[p].validations) {\n    return [];\n  }\n  var self = this;\n  this.errors[p] = [];\n  var value = this.properties[p].value;\n  var validations = this.properties[p].validations;\n  var options = {\n    old: this.properties[p].__oldValue,\n    optional: false,\n    trim: true\n  };\n  var wrap = function (func, options, name) {\n    return function (cb) {\n      if (options.optional && !value) {\n        return cb(null, true);\n      }\n      var called = false;\n      var res = func(value, options, function (result) {\n        if (!result) {\n          self.errors[p].push(name);\n        }\n        if (!called) {\n          cb(null, !!result);\n        }\n      });\n      if (typeof(res) !== 'undefined') {\n        Nohm.logError('Deprecated: Synchronous validation: '+name);\n        called = true;\n        cb(null, res);\n      }\n    };\n  };\n  \n  return validations.map(function (i) {\n    if (typeof i === 'function') {\n      // simple function\n      var funcName = i.toString().match(/^function ([\\w]*)[\\s]?\\(/);\n      var errorName = 'custom_'+ (funcName[1] ? funcName[1] : p);\n      \n      return wrap(i, options, errorName);\n    } else if (typeof i === 'string') {\n      // simple string\n      if (!Nohm.__validators[i]) {\n        Nohm.logError('Trying to access unavailable validator.');\n      }\n      return wrap(Nohm.__validators[i], options, i);\n    } else if (i instanceof Array && i.length > 0) {\n      /* \n      array containing string and options: \n      [ 'someValidtaor', {\n          someOption: false\n        }\n      ]\n      */\n      if (!Nohm.__validators[i[0]]) {\n        Nohm.logError('Trying to access unavailable validator.');\n      }\n      var localOptions = h.$extend(true, {}, options, i[1]);\n      return wrap(Nohm.__validators[i[0]], localOptions, i[0]);\n    } else {\n      Nohm.logError('Invalid validation definition for property \"'+p+'\": '+util.inspect(i));\n    }\n  });\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":7039}]],"length":7039}
{"contributors":[],"silentsave":false,"ts":1342885518240,"patch":[[{"diffs":[[0,"err, arr) {\n"],[1,"    if (err) {\n      Nohm.logError('Database error while checking uniques.', err);\n    }\n"],[0,"    if (Arra"]],"start1":3532,"start2":3532,"length1":24,"length2":113}]],"length":7128,"saved":false}
{"ts":1342886342275,"patch":[[{"diffs":[[0,"pLower;\n"],[1,"      console.log('checking ', propLower, unique_key);\n"],[0,"      va"]],"start1":2300,"start2":2300,"length1":16,"length2":71}]],"length":7183,"saved":false}
{"ts":1342892900825,"patch":[[{"diffs":[[0,"er;\n"],[-1,"      console.log('checking ', propLower, unique_key);\n"],[0,"    "]],"start1":2304,"start2":2304,"length1":63,"length2":8}]],"length":7128,"saved":false}
