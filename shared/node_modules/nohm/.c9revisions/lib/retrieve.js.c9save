{"ts":1341350139358,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var Nohm = null;\nexports.setNohm = function (originalNohm) {\n  Nohm = originalNohm;\n};\n\nvar async = require('async'),\n    h = require(__dirname + '/helpers');\n\n/**\n * Check if a given id exists in the DB.\n */\nexports.exists = function (id, callback) {\n  this.getClient().sismember(Nohm.prefix.idsets+this.modelName, id, function (err, found) {\n    Nohm.logError(err);\n    callback(!!found);\n  });\n};\n\nvar convertIdsToInt = function (ids, callback) {\n  if (this.idGenerator === 'increment' && Array.isArray(ids)) {\n    ids = ids.map(function (val) {\n      return parseInt(val, 10);\n    });\n  }\n  callback(ids);\n}\n\n/**\n * Retrieves the hash data by id and puts it into the properties.\n */\nexports.load = function (id, callback) {\n  var self = this;\n  if (!id) {\n    Nohm.logError('Trying to pass load() a wrong kind of id. Needs to be a number over 0. (still trying to load it though)');\n  }\n  this.getClient().hgetall(this.getHashKey(id), function (err, values) {\n    var p, value,\n        keys = values ? Object.keys(values) : [],\n        return_props = {};\n    if (err) {\n      Nohm.logError('loading a hash produced an error: ' + err);\n    }\n    if (Array.isArray(keys) && keys.length > 0) {\n      for (p in values) {\n        if (values.hasOwnProperty(p) && self.properties.hasOwnProperty(p)) {\n          value = values[p] !== null ? values[p].toString() : null;\n          if (self.properties[p].load_pure) {\n            self.properties[p].value = value;\n          } else {\n            self.p(p, value);\n          }\n          return_props[p] = self.p(p);\n          self.__resetProp(p);\n        } else if ( ! self.properties.hasOwnProperty(p)) {\n          Nohm.logError('WARNING: A hash in the DB contained a key that is not in the model definition. This might be because of model changes or database corruption/intrusion.')\n        }\n      }\n      self.id = id;\n      self.__inDB = true;\n      self.__loaded = true;\n    } else if (!err) {\n      err = 'not found';\n    }\n    if (typeof(callback) === 'function') {\n      callback.call(self, err, return_props);\n    }\n  });\n};\n\n\n/**\n * Finds ids of objects by search arguments\n */\nexports.find = function find(searches, callback) {\n  var self = this, sets = [], zsetKeys = [], s, prop,\n  returnFunction = function (err, values) {\n    var found = [];\n    Nohm.logError(err);\n    if (Array.isArray(values) && values.length > 0) {\n      values = values.forEach(function (val) {\n        if (val) {\n          found.push(val);\n        }\n      });\n    } else if ( ! Array.isArray(values) && values !== null) {\n      found = [values];\n    } else if (values === null) {\n      found = [];\n    }\n    convertIdsToInt(found, function (ids) {\n      callback.call(self, err, ids);\n    });\n  },\n  getSets = function (callback) {\n    self.getClient().sinter(sets, callback);\n  },\n  getSingleZSet = function (zSet, callback) {\n    var rangeCallback = function (err, values) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, values);\n      }\n    };\n    var options = zSet.options;\n    if ( ! options.min && options.min !== 0)\n      options.min = '-inf';\n    if ( ! options.max && options.max !== 0)\n      options.max = '+inf';\n    if ( ! options.offset && options.offset !== 0)\n      options.offset = '+inf';\n    if (options.limit) {\n      self.getClient().zrangebyscore(zSet.key, options.min, options.max,\n                      'LIMIT', options.offset, options.limit,\n                      rangeCallback);\n    } else {\n      self.getClient().zrangebyscore(zSet.key, options.min, options.max,\n                      rangeCallback);\n    }\n  },\n  getZSets = function (callback) {\n    async.map(zsetKeys, getSingleZSet, function done (err, arr) {\n      var ids = h.idIntersection.apply(null, arr);\n      callback(err, ids);\n    });\n  };\n  \n  \n  if (typeof searches === 'function') {\n    callback = searches;\n    searches = {};\n  }\n  for (s in searches) {\n    if (searches.hasOwnProperty(s) && this.properties.hasOwnProperty(s)) {\n      prop = this.properties[s];\n      if (prop.unique) {\n        if (prop.type === 'string') {\n          if ( ! searches[s].toLowerCase) {\n            return returnFunction('Invalid search parameters: Searching for a unique (type \"string\") with a non-string value is not supported.');\n          }\n          searches[s] = searches[s].toLowerCase()\n        }\n        var key = Nohm.prefix.unique+self.modelName+':'+s+':'+searches[s];\n        return this.getClient().get([key], returnFunction);\n      }\n      var isNum = ! isNaN(parseInt(searches[s], 10));\n      if (prop.index && ( ! prop.__numericIndex || isNum) ) {\n        sets.push(Nohm.prefix.index + self.modelName + ':' + s + ':' + searches[s]);\n      } else if (prop.__numericIndex) {\n        zsetKeys.push({\n          key: Nohm.prefix.scoredindex + self.modelName + ':' + s,\n          options: searches[s]\n        });\n      }\n    }\n  }\n  if (sets.length === 0 && zsetKeys.length === 0) {\n    if (JSON.stringify(searches) != '{}') {\n      Nohm.logError(\"Invalid search: Index not found.\");\n      return returnFunction(null, []);\n    }\n    // no specific searches, retrieve all ids\n    this.getClient().smembers(Nohm.prefix.idsets + this.modelName, returnFunction);\n  } else if (zsetKeys.length === 0) {\n    getSets(returnFunction);\n  } else if (sets.length === 0) {\n    getZSets(returnFunction);\n  } else {\n    getSets(function (err, setids) {\n      getZSets(function (err2, zsetids) {\n        if (err2) {\n          err = [err, err2];\n        }\n        returnFunction(err, h.idIntersection(setids, zsetids).sort());\n      });\n    });\n  }\n};\n\nexports.sort = function (options, ids) {\n  var callback = h.getCallback(arguments);\n  if ( ! Array.isArray(ids) || ids.length === 0) {\n    ids = false;\n  }\n  options = typeof(options) !== 'function' && typeof(options) === 'object' && Object.keys(options).length > 0 ? options : {};\n  \n  if (ids.length > 0 && options === {}) {\n    return callback(ids.sort());\n  }\n  \n  if ( ! options.field || ! this.properties.hasOwnProperty(options.field)) {\n    callback('invalid field in options', ids);\n    return Nohm.logError('Invalid field in sort() options: ' + options.field);\n  }\n  \n  var field_type = this.properties[options.field].type;\n  \n  var alpha = options.alpha ||  field_type === 'string' ? 'ALPHA' : '';\n  var direction = options.direction ? options.direction : 'ASC';\n  var scored = Nohm.indexNumberTypes.indexOf(field_type) !== -1;\n  var start = 0;\n  var stop = 100;\n  if (Array.isArray(options.limit) && options.limit.length > 0) {\n    start = options.limit[0];\n    if (scored) { // the limit arguments for sets and sorted sets work differently\n      // stop is a 0-based index from the start of all zset members\n      stop = options.limit[1] ? start+options.limit[1] : start+stop;\n      stop--;\n    } else {\n      // stop is a 1-based index from the defined start limit (the wanted behaviour)\n      stop = options.limit[1] || stop;\n    }\n  }\n  var idset_key = Nohm.prefix.idsets+this.modelName;\n  var zset_key = Nohm.prefix.scoredindex+this.modelName+':'+options.field;\n  var client = this.getClient();\n  var tmp_key;\n  \n  if (ids) {\n    // to get the intersection of the given ids and all ids on the server we first\n    // temporarily store the given ids either in a set or sorted set and then return the intersection\n    \n    client = client.multi(); \n    \n    if (scored) {\n      tmp_key = zset_key+':tmp_sort:'+(+ new Date()) + Math.ceil(Math.random()*1000);\n      var tmp_zadd_args = [tmp_key];\n      ids.forEach(function (id) {\n        tmp_zadd_args.push(0, id);\n      });\n      client.zadd(tmp_zadd_args);\n      client.zinterstore([tmp_key, 2, tmp_key, zset_key]);\n      zset_key = tmp_key;\n    } else {\n      tmp_key = idset_key+':tmp_sort:'+(+ new Date()) + Math.ceil(Math.random()*1000);\n      ids.unshift(tmp_key);\n      client.SADD(ids);\n      client.SINTERSTORE([tmp_key, tmp_key, idset_key]);\n      idset_key = tmp_key;\n    }\n  }\n  if (scored) {\n    sortScored.call(this, client, zset_key, direction, start, stop, callback);\n  } else {\n    sortNormal.call(this, client, idset_key, options.field, alpha, direction, start, stop, callback);\n  }\n  if (ids) {\n    client.del(tmp_key);\n    client.exec(Nohm.logError);    \n  }\n};\n\nvar sortNormal = function (client, idset_key, field, alpha, direction, start, stop, callback) {\n  var hash_key = Nohm.prefix.hash+this.modelName;\n  client.sort([idset_key, \n    'BY', hash_key+':*->'+field, \n    'LIMIT', start, stop,\n    direction,\n    alpha],\n    callback);\n};\n\n\nvar sortScored = function (client, zset_key, direction, start, stop, callback) {\n  var method = direction && direction === 'DESC' ? 'ZREVRANGE' : 'ZRANGE';\n  if (start < 0 || stop < 0) {\n    Nohm.logError('Notice: tried to limit a scored sort with a negative start('+start+') or stop('+stop+').');\n  }\n  if (stop < start) {\n    Nohm.logError('Notice: tried to limit a scored sort with a higher start('+start+') than stop('+stop+').');\n  }\n  client[method](\n    [zset_key,\n      start, stop],\n    callback\n  );\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":9024}]],"length":9024}
{"contributors":[],"silentsave":false,"ts":1341350161234,"patch":[[{"diffs":[[0,"ed a key"],[1," ('+p+')"],[0," that is"]],"start1":1705,"start2":1705,"length1":16,"length2":24}]],"length":9032,"saved":false}
{"ts":1341350352607,"patch":[[{"diffs":[[0,"        "],[-1,"if ("],[1,"var is_enumerable = "],[0,"values.h"]],"start1":1220,"start2":1220,"length1":20,"length2":36},{"diffs":[[0,"y(p)"],[-1," && self.properties.hasOwnProperty(p)"],[1,";\n        var is_property = p !== '__meta_version' && self.properties.hasOwnProperty(p)\n        if (is_enumerable && is_property"],[0,") {\n"]],"start1":1268,"start2":1268,"length1":45,"length2":136}]],"length":9139,"saved":false}
{"ts":1341350355322,"patch":[[{"diffs":[[0,"perty(p)"],[1,";"],[0,"\n       "]],"start1":1351,"start2":1351,"length1":16,"length2":17}]],"length":9140,"saved":false}
{"ts":1341350399196,"patch":[[{"diffs":[[0," var is_"],[-1,"property"],[1,"meta"],[0," = p !=="]],"start1":1281,"start2":1281,"length1":24,"length2":20},{"diffs":[[0,"version'"],[-1," &&"],[1,";\n        var is_property ="],[0," self.pr"]],"start1":1310,"start2":1310,"length1":19,"length2":43},{"diffs":[[0,"property"],[1," && is_meta"],[0,") {\n    "]],"start1":1413,"start2":1413,"length1":16,"length2":27},{"diffs":[[0,"e if ( !"],[1," is_meta && !"],[0," self.pr"]],"start1":1740,"start2":1740,"length1":16,"length2":29}]],"length":9184,"saved":false}
{"ts":1341350418106,"patch":[[{"diffs":[[0,"eta = p "],[-1,"!"],[1,"="],[0,"== '__me"]],"start1":1290,"start2":1290,"length1":17,"length2":17}]],"length":9184,"saved":false}
{"ts":1341350421693,"patch":[[{"diffs":[[0,"perty &&"],[1," !"],[0," is_meta"]],"start1":1416,"start2":1416,"length1":16,"length2":18}]],"length":9186,"saved":false}
{"contributors":[],"silentsave":false,"ts":1342362601030,"patch":[[{"diffs":[[0,"value);\n"],[1,"            \n            if (self.p(p) !== value) {\n              console.log('loaded', p, ' and it was different after typecasting: ', value, self.p(p));\n            }\n"],[0,"        "]],"start1":1639,"start2":1639,"length1":16,"length2":185}]],"length":9355,"saved":false}
{"ts":1342362809665,"patch":[[{"diffs":[[0,".p(p) !="],[-1,"="],[0," value) "]],"start1":1680,"start2":1680,"length1":17,"length2":16}]],"length":9354,"saved":false}
{"ts":1342362918854,"patch":[[{"diffs":[[0,"e);\n"],[-1,"            \n            if (self.p(p) != value) {\n              console.log('loaded', p, ' and it was different after typecasting: ', value, self.p(p));\n            }\n"],[0,"    "]],"start1":1643,"start2":1643,"length1":176,"length2":8}]],"length":9186,"saved":false}
{"contributors":[],"silentsave":true,"ts":1342892970957,"patch":[[{"diffs":[[0,"    "],[-1,"var is_enumerable = "],[1,"if ("],[0,"valu"]],"start1":1224,"start2":1224,"length1":28,"length2":12},{"diffs":[[0,"y(p)"],[-1,";\n        var is_meta = p === '__meta_version';\n        var is_property = self.properties.hasOwnProperty(p);\n        if (is_enumerable && is_property && ! is_meta"],[1," && self.properties.hasOwnProperty(p)"],[0,") {\n"]],"start1":1252,"start2":1252,"length1":170,"length2":45},{"diffs":[[0," ( !"],[-1," is_meta && !"],[0," sel"]],"start1":1605,"start2":1605,"length1":21,"length2":8},{"diffs":[[0," key"],[-1," ('+p+')"],[0," tha"]],"start1":1709,"start2":1709,"length1":16,"length2":8}]],"length":9024,"saved":false}
{"contributors":[],"silentsave":false,"ts":1354638328631,"patch":[[{"diffs":[[0,"        "],[-1,"if ("],[1,"var is_enumerable = "],[0,"values.h"]],"start1":1220,"start2":1220,"length1":20,"length2":36},{"diffs":[[0,"y(p)"],[-1," && self.properties.hasOwnProperty(p)"],[1,";\n        var is_meta = p === '__meta_version';\n        var is_property = self.properties.hasOwnProperty(p);\n        if (is_enumerable && is_property && ! is_meta"],[0,") {\n"]],"start1":1268,"start2":1268,"length1":45,"length2":170},{"diffs":[[0,"e if ( !"],[1," is_meta && !"],[0," self.pr"]],"start1":1742,"start2":1742,"length1":16,"length2":29},{"diffs":[[0,"ed a key"],[1," ('+p+')"],[0," that is"]],"start1":1859,"start2":1859,"length1":16,"length2":24},{"diffs":[[0,"});\n};\n\n"],[1,"/**\n * Finds ids of objects and loads them.\n */\nexports.findAndLoad = function findAndLoad(searches, callback) {\n  var self = this;\n  this.find(searches, function (err, ids) {\n    if (err) {\n      callback(err, ids);\n    } else if (ids.length == 0) {\n      callback(\"not found\", ids);\n    } else {\n      if (ids.length > 0) {\n        async.map(ids, function (id, done) {\n          self.load(id, function (err, props) {\n            done(err, self);\n          });\n        }, callback);\n      }\n    }\n  });\n};\n"],[0,"\n/**\n * "]],"start1":2231,"start2":2231,"length1":16,"length2":523}]],"length":9693,"saved":false}
{"ts":1354638345904,"patch":[[{"diffs":[[0,"ength =="],[1,"="],[0," 0) {\n  "]],"start1":2476,"start2":2476,"length1":16,"length2":17},{"diffs":[[0,"(err"],[-1,", props"],[0,") {\n"]],"start1":2644,"start2":2644,"length1":15,"length2":8}]],"length":9687,"saved":false}
{"contributors":[],"silentsave":false,"ts":1354638404202,"patch":[[{"diffs":[[0,"ound\", ids);"],[1,"a"],[0,"\n    } else "]],"start1":2512,"start2":2512,"length1":24,"length2":25},{"diffs":[[0,"unction (err"],[1,", props"],[0,") {\n        "]],"start1":2637,"start2":2637,"length1":24,"length2":31}]],"length":9695,"saved":false}
{"ts":1354638405439,"patch":[[{"diffs":[[0,"\", ids);"],[-1,"a"],[0,"\n    } e"]],"start1":2516,"start2":2516,"length1":17,"length2":16}]],"length":9694,"saved":false}
{"ts":1354638408689,"patch":[[{"diffs":[[0,"(err"],[-1,", props"],[0,") {\n"]],"start1":2644,"start2":2644,"length1":15,"length2":8}]],"length":9687,"saved":false}
{"ts":1354640013275,"patch":[[{"diffs":[[0,"{\n          "],[1,"var "],[0,"self.load(id"]],"start1":2609,"start2":2609,"length1":24,"length2":28}]],"length":9691,"saved":false}
{"ts":1354640016074,"patch":[[{"diffs":[[0,"        var "],[1,"result = nohm"],[0,"self.load(id"]],"start1":2613,"start2":2613,"length1":24,"length2":37}]],"length":9704,"saved":false}
{"ts":1354640018457,"patch":[[{"diffs":[[0,"t = nohm"],[1,".fa"],[0,"self.loa"]],"start1":2630,"start2":2630,"length1":16,"length2":19}]],"length":9707,"saved":false}
{"ts":1354640019852,"patch":[[{"diffs":[[0," nohm.fa"],[1,"ctory"],[0,"self.loa"]],"start1":2633,"start2":2633,"length1":16,"length2":21}]],"length":9712,"saved":false}
{"ts":1354640023055,"patch":[[{"diffs":[[0,"var "],[-1,"result"],[1,"instance"],[0," = n"]],"start1":2621,"start2":2621,"length1":14,"length2":16}]],"length":9714,"saved":false}
{"ts":1354640026228,"patch":[[{"diffs":[[0,".factory"],[1,"("],[0,"self.loa"]],"start1":2640,"start2":2640,"length1":16,"length2":17}]],"length":9715,"saved":false}
{"ts":1354640027545,"patch":[[{"diffs":[[0,"ry(self."],[1,"self."],[0,"load(id,"]],"start1":2646,"start2":2646,"length1":16,"length2":21}]],"length":9720,"saved":false}
{"ts":1354640031323,"patch":[[{"diffs":[[0,"ry(self."],[1,"modelName)"],[0,"self.loa"]],"start1":2646,"start2":2646,"length1":16,"length2":26}]],"length":9730,"saved":false}
{"ts":1354640032733,"patch":[[{"diffs":[[0,"delName)"],[1,";\n          "],[0,"self.loa"]],"start1":2656,"start2":2656,"length1":16,"length2":28}]],"length":9742,"saved":false}
{"ts":1354640036564,"patch":[[{"diffs":[[0,"        "],[-1,"self"],[1,"instance"],[0,".load(id"]],"start1":2668,"start2":2668,"length1":20,"length2":24}]],"length":9746,"saved":false}
{"ts":1354640041695,"patch":[[{"diffs":[[0,"ne(err, "],[-1,"self"],[1,"instance"],[0,");\n     "]],"start1":2725,"start2":2725,"length1":20,"length2":24}]],"length":9750,"saved":false}
