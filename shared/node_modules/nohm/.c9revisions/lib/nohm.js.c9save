{"ts":1342144645997,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var h = require(__dirname + '/helpers');\nvar async = require('async');\nvar crypto = require('crypto');\n\n/**\n * The Nohm object used for some general configuration and model creation.\n * @namespace Nohm\n * @exports exports as Nohm\n */\nfunction Nohm () {\n}\n\n/**\n * The redis prefixed key object.\n * Defaults to prefixing with 'nohm' which then creates keys like 'nohm:idsets:someModel'.\n * @static\n */\nNohm.prefix = h.getPrefix('nohm');\n\n/**\n * The property types that get indexed in a sorted set.\n * This should not be changed since it can invalidate already existing data.\n * @static\n */\nNohm.indexNumberTypes = ['integer', 'float', 'timestamp'];\n\n/**\n * The current global nohm redis client\n * @static\n */\nNohm.client = null;\n\n/**\n * Whether to store the meta values about models.\n * This is used for example by the admin app.\n * Defaults to true.\n * @static\n */\nNohm.meta = true;\n\n/**\n * Model cache\n */\nvar models = {};\n\n/**\n * Creates and returns a new model with the given name and options.\n * @param {String} Name Name of the model. This needs to be unique and is used in data storage. Thus <b>changing this will invalidate existing data</b>!\n * @param {Object} Option This is an object containing the actual model definitions. These are: properties, methods (optional) and the client (optional) to be used.\n * @static\n */\nNohm.model = function (name, options) {\n  if ( ! name ) {\n    this.logError('When creating a new model you have to provide a name!');\n  }\n  \n  var obj = function (id, cb) {\n    this.init(options);\n    // if this is changed, check if the factory needs to be changed as well!\n    if(typeof(id) !== 'undefined' && typeof(cb) === 'function') {\n      this.load(id, cb);\n    }\n  };\n  obj.prototype = new Nohm();\n  \n  obj.prototype.modelName = name;\n\n  obj.prototype.idGenerator = options.idGenerator || 'default';\n  \n  var meta = {\n    inDb: false\n  };\n  meta.properties = options.properties;\n  meta.version = _meta_version(meta.properties, obj);\n  \n  obj.prototype.meta = meta;\n  \n  // this creates a few functions for short-form like: SomeModel.load(1, function (err, props) { /* `this` is someModelInstance here */ });\n  var shortFormFuncs = ['load', 'find', 'save', 'sort', 'subscribe', 'subscribeOnce', 'unsubscribe'];\n  shortFormFuncs.forEach(function (val) {\n    obj[val] = function () {\n      var instance = new obj();\n      instance[val].apply(instance, Array.prototype.slice.call(arguments, 0));\n    };\n  });\n\n  // special short form for removal because we first need to set the id on the instance\n  obj.remove = function (id, cb) {\n    var instance = new obj();\n    instance.id = id;\n    instance.remove(cb);\n  };\n\n  models[name] = obj;\n\n  return obj;\n};\n\nvar _meta_version = function (properties, obj) {\n  var hash = crypto.createHash('sha1');\n  \n  hash.update(JSON.stringify(properties));\n  hash.update(JSON.stringify(obj.prototype.modelName));\n  hash.update(obj.prototype.idGenerator.toString());\n  \n  return hash.digest('hex');\n};\n\n/**\n * Factory to produce instances of models\n * \n * @param {String} name Name of the model (as given to Nohm.model())\n * @param {Number} [id] Id to be loaded. This requires the callback.\n * @param {Function} [callback] Called when the user is loaded from the db.\n * @returns {ModelInstance} Returns the new model instance\n * @static\n */\nNohm.factory = function factory(name, id, callback) {\n  if ( ! models.hasOwnProperty(name)) {\n    Nohm.logError('Trying to instantiate inexistant model: '+name);\n    return false;\n  }\n  var obj = new models[name]();\n  if(typeof(id) !== 'undefined' && typeof(callback) === 'function') {\n    obj.id = id;\n    obj.load(id, callback);\n  }\n  return obj;\n};\n\n/**\n * Gets all registered models.\n * \n * @returns {Object} Object containing all registered models\n * @static\n */\nNohm.getModels = function getModels() {\n  return models;\n};\n\n/**\n * This function is used whenever an error occurs in nohm.\n * You can override this to whatever you want.\n * By default it only does a console.dir(errorObject);\n * @static\n */\nNohm.logError = function logError(err) {\n  if (err) {\n    console.dir({\n      name: \"Nohm Error\",\n      message: err\n    });\n  }\n};\n\n/**\n * Set the Nohm global redis client.\n * Note: this will not affect models that have a client set on their own.\n * @static\n */\nNohm.setPrefix = function (prefix) {\n  Nohm.prefix = h.getPrefix(prefix);\n};\n\n/**\n * Set the Nohm global redis client.\n * Note: this will not affect models that have a client set on their own.\n * @static\n */\nNohm.setClient = function (client) {\n  Nohm.client = client;\n  if ( ! client.connected) {\n    Nohm.logError('Warning: setClient() received a redis client that is not connected yet. Consider waiting for an established connection before setting it.');\n  }\n};\n\n\nNohm.__validators = {};\nvar __extraValidators = [];\n/**\n * Set some extra validator files. These will also be exported to the browser via connect middleware if used.\n * @static\n */\nNohm.setExtraValidations = function (files) {\n  if ( ! Array.isArray(files)) {\n    files = [files];\n  }\n  files.forEach(function (path) {\n    if (__extraValidators.indexOf(path) === -1) {\n      __extraValidators.push(path);\n      var validators = require(path);\n      Object.keys(validators).forEach(function (name) {\n        Nohm.__validators[name] = validators[name];\n      });\n    }\n  });\n};\n\nNohm.getExtraValidatorFileNames = function () {\n  return __extraValidators;\n};\n\n// prototype methods:\n\n/**\n * Returns the key needed to retreive a hash (properties) of an instance.\n * @param {Number} id Id of the model instance.\n */\nNohm.prototype.getHashKey = function (id) {\n  return Nohm.prefix.hash + this.modelName + ':' + id;\n};\n\n/**\n * Returns the client of either the model (if set) or the global Nohm object.\n */\nNohm.prototype.getClient = function () {\n  var client = this.client || Nohm.client;\n  if ( ! client.connected) {\n    Nohm.logError('Warning: Tried accessing a redis client that is not connected to a database. The redis client should buffer the commands and send them once connected. But if it can\\'t connect they are lost.');\n  }\n  return client;\n};\n\nvar addMethods = function (methods) {\n  for (var name in methods) {\n    if (methods.hasOwnProperty(name) && typeof(methods[name]) === 'function') {\n      if (this[name]) {\n        this['_super_'+name] = this[name];\n      }\n      this[name] = methods[name].bind(this);\n    }\n  }\n};\n\nNohm.prototype.init = function (options) {\n  if (typeof(options.client) === 'undefined' && Nohm.client === null) {\n    Nohm.logError('Did not find a viable redis client in Nohm or the model: '+this.modelName);\n    return false;\n  }\n  \n  if ( ! this.meta.inDb) {\n    __updateMeta.call(this);\n  }\n\n  if (typeof(options.client) !== 'undefined') {\n    this.client = options.client;\n  }\n\n  this.properties = {};\n  this.errors = {};\n\n  // initialize the properties\n  if (options.hasOwnProperty('properties')) {\n    \n    for (var p in options.properties) {\n      if (options.properties.hasOwnProperty(p)) {\n        this.properties[p] = h.$extend(true, {}, options.properties[p]); // deep copy\n        var defaultValue = options.properties[p].defaultValue || 0;\n        if (typeof(defaultValue) === 'function') {\n          defaultValue = defaultValue();\n        }\n        if (typeof(options.properties[p].type) === 'function') {\n          // behaviours should not be called on initialization\n          this.properties[p].value = defaultValue;\n        } else {\n          this.property(p, defaultValue); // this ensures typecasing\n        }\n        this.__resetProp(p);\n        this.errors[p] = [];\n      }\n    }\n  }\n  \n  if (options.hasOwnProperty('methods')) {\n    addMethods.call(this, options.methods);\n  }\n\n  if (options.hasOwnProperty('publish')) {\n    this.publish = options.publish;\n  }\n\n  this.relationChanges = [];\n\n  this.id = null;\n  this.__inDB = false;\n  this.__loaded = false;\n};\n\n\n\nvar __updateMeta = function () {\n  if ( ! Nohm.meta) {\n    return false;\n  }\n  var self = this;\n  \n  var version_key = Nohm.prefix.meta.version + this.modelName;\n  var idGenerator_key = Nohm.prefix.meta.idGenerator + this.modelName;\n  var properties_key = Nohm.prefix.meta.properties + this.modelName;\n  \n  this.getClient().get(version_key, function (err, db_version) {\n    if (err) {\n      Nohm.logError(err);\n    } else if (self.meta.version !== db_version) {\n      async.parallel({\n        version: function (next) {\n          self.getClient().set(version_key, self.meta.version, next);\n        },\n        idGenerator: function (next) {\n          self.getClient().set(idGenerator_key, self.idGenerator.toString(), next);\n        },\n        properties: function (next) {\n          self.getClient().set(properties_key, JSON.stringify(self.meta.properties), next);\n        }\n      }, function (err) {\n        if (err) {\n          Nohm.logError(err);\n        } else {\n          self.meta.inDb = true;\n        }\n      });\n    }\n  });\n};\n\n/**\n * DO NOT USE THIS UNLESS YOU ARE ABSOLUTELY SURE ABOUT IT!\n * \n * Deletes any keys from the db that start with nohm prefixes.\n * \n * DO NOT USE THIS UNLESS YOU ARE ABSOLUTELY SURE ABOUT IT!\n * \n * @param {Object} [redis] You can specify the redis client to use. Default: Nohm.client\n * @param {Function} [callback] Called after all keys are deleted.\n */\nNohm.purgeDb = function (redis, callback) {\n  callback = h.getCallback(arguments);\n  redis = typeof(redis) !== 'function' || Nohm.client;\n  var delKeys = function (prefix, next) {\n    redis.keys(prefix+'*', function (err, keys) {\n      if (err || keys.length === 0) {\n        next(err);\n      } else {\n        keys.push(next);\n        redis.del.apply(redis, keys);\n      }\n    });\n  };\n  var deletes = [];\n  \n  Object.keys(Nohm.prefix).forEach(function (key) {\n    deletes.push(async.apply(delKeys, Nohm.prefix[key]));\n  });\n  \n  async.series(deletes, function (err) {\n    callback(err);\n  });\n};\n\nvar moduleNames = ['properties', 'retrieve', 'validation', 'store', 'relations', 'connectMiddleware', 'pubsub'],\n    modules = {};\n\nmoduleNames.forEach(function (name) {\n  // first integrate all the modules\n  modules[name] = require(__dirname+'/'+name);\n  h.prototypeModule(Nohm, modules[name]);\n});\nmoduleNames.forEach(function (name) {\n  // then give them the complete Nohm.\n  if (typeof(modules[name].setNohm) !== 'undefined')\n    modules[name].setNohm(Nohm);\n});\n\nexports.Nohm = Nohm;\n\n"]],"start1":0,"start2":0,"length1":0,"length2":10350}]],"length":10350}
{"contributors":[],"silentsave":false,"ts":1342144726490,"patch":[[{"diffs":[[0,"elName;\n"],[1,"  var properties = traverse(self.meta.properties).map(function (x) { \n    if (typeof x === 'function') {\n      return String(x) \n    } else {\n      return x;\n    }\n  });\n"],[0,"  \n  thi"]],"start1":8161,"start2":8161,"length1":16,"length2":186},{"diffs":[[0,"ringify("],[-1,"self.meta.properties"],[0,"), next)"]],"start1":8864,"start2":8864,"length1":36,"length2":16}]],"length":10500,"saved":false}
{"ts":1342144802561,"patch":[[{"diffs":[[0,"e;\n};\n\n\n"],[1,"var traverse = require('traverse');"],[0,"\nvar __u"]],"start1":7858,"start2":7858,"length1":16,"length2":51},{"diffs":[[0,"ringify("],[1,"properties"],[0,"), next)"]],"start1":8899,"start2":8899,"length1":16,"length2":26}]],"length":10545,"saved":false}
{"ts":1342144880459,"patch":[[{"diffs":[[0,"rypto');"],[1,"\nvar traverse = require('traverse');"],[0,"\n\n/**\n *"]],"start1":94,"start2":94,"length1":16,"length2":52},{"diffs":[[0,";\n\n\n"],[-1,"var traverse = require('traverse');\n"],[0,"var "]],"start1":7898,"start2":7898,"length1":44,"length2":8}]],"length":10545,"saved":false}
{"ts":1342145823078,"patch":[[{"diffs":[[0,") {\n"],[-1,"}\n\n/**\n * The redis prefixed key object.\n * Defaults to prefixing with 'nohm' which then creates keys like 'nohm:idsets:someModel'.\n * @static\n */\nNohm.prefix = h.getPrefix('nohm');\n\n/**\n * The property types that get indexed in a sorted set.\n * This should not be changed since it can invalidate already existing data.\n * @static\n */\nNohm.indexNumberTypes = ['integer', 'float', 'timestamp'];\n\n/**\n * The current global nohm redis client\n * @static\n */\nNohm.client = null;\n\n/**\n * Whether to store the meta values about models.\n * This is used for example by the admin app.\n * Defaults to true.\n * @static\n */\nNohm.meta = true;\n\n/**\n * Model cache\n */\nvar models = {};\n\n/**\n * Creates and returns a new model with the given name and options.\n * @param {String} Name Name of the model. This needs to be unique and is used in data storage. Thus <b>changing this will invalidate existing data</b>!\n * @param {Object} Option This is an object containing the actual model definitions. These are: properties, methods (optional) and the client (optional) to be used.\n * @static\n */\nNohm"],[1,"  var models = {};\n  this.model = "],[0,".mod"]],"start1":285,"start2":285,"length1":1088,"length2":42},{"diffs":[[0," options) {\n"],[1,"  "],[0,"  if ( ! nam"]],"start1":347,"start2":347,"length1":24,"length2":26},{"diffs":[[0," ! name ) {\n"],[1,"  "],[0,"    this.log"]],"start1":367,"start2":367,"length1":24,"length2":26},{"diffs":[[0,"e!');\n  "],[-1,"}\n"],[1,"  }\n  "],[0,"  \n"],[1,"  "],[0,"  var ob"]],"start1":451,"start2":451,"length1":21,"length2":27},{"diffs":[[0,", cb) {\n    "],[1,"  "],[0,"this.init(op"]],"start1":494,"start2":494,"length1":24,"length2":26},{"diffs":[[0,"s);\n    "],[1," "],[1," "],[0,"// if th"]],"start1":524,"start2":524,"length1":16,"length2":18},{"diffs":[[0,"ll!\n    "],[1,"  "],[0,"if(typeo"]],"start1":603,"start2":603,"length1":16,"length2":18},{"diffs":[[0,"n') {\n      "],[1," "],[1," "],[0,"this.load(id"]],"start1":669,"start2":669,"length1":24,"length2":26},{"diffs":[[0,"    "],[1,"  "],[0,"}\n  "],[1," "],[1," "],[0,"};\n"],[1,"  "],[0,"  ob"]],"start1":702,"start2":702,"length1":15,"length2":21},{"diffs":[[0,"w Nohm();\n  "],[1," "],[-1,"\n"],[1," \n  "],[0,"  obj.protot"]],"start1":739,"start2":739,"length1":25,"length2":29},{"diffs":[[0,"= name;\n"],[-1,"\n"],[1,"  \n  "],[0,"  obj.pr"]],"start1":782,"start2":782,"length1":17,"length2":21},{"diffs":[[0,"default';\n  "],[1,"  "],[0,"\n"],[1,"  "],[0,"  var meta ="]],"start1":849,"start2":849,"length1":25,"length2":29},{"diffs":[[0,"eta = {\n"],[1,"  "],[0,"    inDb"]],"start1":873,"start2":873,"length1":16,"length2":18},{"diffs":[[0,": false\n"],[1,"  "],[0,"  };\n"],[1,"  "],[0,"  meta.p"]],"start1":891,"start2":891,"length1":21,"length2":25},{"diffs":[[0,"erties;\n"],[1,"  "],[0,"  meta.v"]],"start1":940,"start2":940,"length1":16,"length2":18},{"diffs":[[0,"obj);\n  "],[-1,"\n"],[1,"  \n  "],[0,"  obj.pr"]],"start1":998,"start2":998,"length1":17,"length2":21},{"diffs":[[0,"meta;\n  "],[-1,"\n"],[1,"  \n "],[0,"  "],[1," "],[0,"// this "]],"start1":1034,"start2":1034,"length1":19,"length2":23},{"diffs":[[0," */ });\n"],[1,"  "],[0,"  var sh"]],"start1":1179,"start2":1179,"length1":16,"length2":18},{"diffs":[[0,"be'];\n  "],[1," "],[1," "],[0,"shortFor"]],"start1":1285,"start2":1285,"length1":16,"length2":18},{"diffs":[[0,") {\n    "],[1,"  "],[0,"obj[val]"]],"start1":1331,"start2":1331,"length1":16,"length2":18},{"diffs":[[0," () {\n      "],[1," "],[1," "],[0,"var instance"]],"start1":1360,"start2":1360,"length1":24,"length2":26},{"diffs":[[0," new obj();\n"],[1,"  "],[0,"      instan"]],"start1":1388,"start2":1388,"length1":24,"length2":26},{"diffs":[[0,"    "],[1,"  "],[0,"};\n  "],[1," "],[1," "],[0,"});\n"],[1,"  "],[0,"\n"],[1,"  "],[0,"  //"]],"start1":1481,"start2":1481,"length1":18,"length2":26},{"diffs":[[0,"nstance\n"],[1,"  "],[0,"  obj.re"]],"start1":1583,"start2":1583,"length1":16,"length2":18},{"diffs":[[0,", cb) {\n    "],[1," "],[1," "],[0,"var instance"]],"start1":1620,"start2":1620,"length1":24,"length2":26},{"diffs":[[0," obj();\n    "],[1,"  "],[0,"instance.id "]],"start1":1652,"start2":1652,"length1":24,"length2":26},{"diffs":[[0,"d = id;\n    "],[1," "],[1," "],[0,"instance.rem"]],"start1":1676,"start2":1676,"length1":24,"length2":26},{"diffs":[[0,"b);\n"],[1,"  "],[0,"  };\n"],[1,"  "],[0,"\n"],[1,"  "],[0,"  mo"]],"start1":1707,"start2":1707,"length1":14,"length2":20},{"diffs":[[0," = obj;\n"],[1,"  "],[0,"\n"],[1,"  "],[0,"  return"]],"start1":1737,"start2":1737,"length1":17,"length2":21},{"diffs":[[0,"rn obj;\n"],[-1,"};"],[1,"  };\n}\n\n/**\n * The redis prefixed key object.\n * Defaults to prefixing with 'nohm' which then creates keys like 'nohm:idsets:someModel'.\n * @static\n */\nNohm.prefix = h.getPrefix('nohm');\n\n/**\n * The property types that get indexed in a sorted set.\n * This should not be changed since it can invalidate already existing data.\n * @static\n */\nNohm.indexNumberTypes = ['integer', 'float', 'timestamp'];\n\n/**\n * The current global nohm redis client\n * @static\n */\nNohm.client = null;\n\n/**\n * Whether to store the meta values about models.\n * This is used for example by the admin app.\n * Defaults to true.\n * @static\n */\nNohm.meta = true;\n\n/**\n * Model cache\n */\nvar models = {};\n\n/**\n * Creates and returns a new model with the given name and options.\n * @param {String} Name Name of the model. This needs to be unique and is used in data storage. Thus <b>changing this will invalidate existing data</b>!\n * @param {Object} Option This is an object containing the actual model definitions. These are: properties, methods (optional) and the client (optional) to be used.\n * @static\n */"],[0,"\n\nvar _m"]],"start1":1756,"start2":1756,"length1":18,"length2":1096}]],"length":10665,"saved":false}
{"ts":1342145834475,"patch":[[{"diffs":[[0,"el ="],[-1," .model ="],[0," fun"]],"start1":318,"start2":318,"length1":17,"length2":8}]],"length":10656,"saved":false}
{"ts":1342145861152,"patch":[[{"diffs":[[0,"atic\n */"],[1,"\nNohm.model = function (name, options) {\n  if ( ! name ) {\n    this.logError('When creating a new model you have to provide a name!');\n  }\n  \n  var obj = function (id, cb) {\n    this.init(options);\n    // if this is changed, check if the factory needs to be changed as well!\n    if(typeof(id) !== 'undefined' && typeof(cb) === 'function') {\n      this.load(id, cb);\n    }\n  };\n  obj.prototype = new Nohm();\n  \n  obj.prototype.modelName = name;\n\n  obj.prototype.idGenerator = options.idGenerator || 'default';\n  \n  var meta = {\n    inDb: false\n  };\n  meta.properties = options.properties;\n  meta.version = _meta_version(meta.properties, obj);\n  \n  obj.prototype.meta = meta;\n  \n  // this creates a few functions for short-form like: SomeModel.load(1, function (err, props) { /* `this` is someModelInstance here */ });\n  var shortFormFuncs = ['load', 'find', 'save', 'sort', 'subscribe', 'subscribeOnce', 'unsubscribe'];\n  shortFormFuncs.forEach(function (val) {\n    obj[val] = function () {\n      var instance = new obj();\n      instance[val].apply(instance, Array.prototype.slice.call(arguments, 0));\n    };\n  });\n\n  // special short form for removal because we first need to set the id on the instance\n  obj.remove = function (id, cb) {\n    var instance = new obj();\n    instance.id = id;\n    instance.remove(cb);\n  };\n\n  models[name] = obj;\n\n  return obj;\n};"],[0,"\n\nvar _m"]],"start1":2827,"start2":2827,"length1":16,"length2":1376}]],"length":12016,"saved":false}
{"ts":1342146129291,"patch":[[{"diffs":[[0,"j;\n  };\n"],[1,"  return this;\n"],[0,"}\n\n/**\n "]],"start1":1752,"start2":1752,"length1":16,"length2":31}]],"length":12031,"saved":false}
{"ts":1342146428407,"patch":[[{"diffs":[[0,"j;\n  };\n"],[1,"  require('util').inherits(this, Nohm);\n"],[0,"  return"]],"start1":1752,"start2":1752,"length1":16,"length2":56}]],"length":12071,"saved":false}
{"ts":1342146505792,"patch":[[{"diffs":[[0,") {\n"],[-1,"  var models = {};\n  this.model = function (name, options) {\n    if ( ! name ) {\n      this.logError('When creating a new model you have to provide a name!');\n    }\n    \n    var obj = function (id, cb) {\n      this.init(options);\n      // if this is changed, check if the factory needs to be changed as well!\n      if(typeof(id) !== 'undefined' && typeof(cb) === 'function') {\n        this.load(id, cb);\n      }\n    };\n    obj.prototype = new Nohm();\n    \n    obj.prototype.modelName = name;\n  \n    obj.prototype.idGenerator = options.idGenerator || 'default';\n    \n    var meta = {\n      inDb: false\n    };\n    meta.properties = options.properties;\n    meta.version = _meta_version(meta.properties, obj);\n    \n    obj.prototype.meta = meta;\n    \n    // this creates a few functions for short-form like: SomeModel.load(1, function (err, props) { /* `this` is someModelInstance here */ });\n    var shortFormFuncs = ['load', 'find', 'save', 'sort', 'subscribe', 'subscribeOnce', 'unsubscribe'];\n    shortFormFuncs.forEach(function (val) {\n      obj[val] = function () {\n        var instance = new obj();\n        instance[val].apply(instance, Array.prototype.slice.call(arguments, 0));\n      };\n    });\n  \n    // special short form for removal because we first need to set the id on the instance\n    obj.remove = function (id, cb) {\n      var instance = new obj();\n      instance.id = id;\n      instance.remove(cb);\n    };\n  \n    models[name] = obj;\n  \n    return obj;\n  };\n  require('util').inherits(this, Nohm);\n  return this;\n"],[0,"}\n\n/"]],"start1":285,"start2":285,"length1":1534,"length2":8}]],"length":10545,"saved":false}
{"ts":1342146541606,"patch":[[{"diffs":[[0,"ame, options"],[1,", temp"],[0,") {\n  if ( !"]],"start1":1389,"start2":1389,"length1":24,"length2":30},{"diffs":[[0,";\n  };\n\n"],[1,"  if ( ! temp) {\n  "],[0,"  models"]],"start1":2683,"start2":2683,"length1":16,"length2":35},{"diffs":[[0,"] = obj;"],[1,"\n  }"],[0,"\n\n  retu"]],"start1":2723,"start2":2723,"length1":16,"length2":20}]],"length":10574,"saved":false}
{"ts":1342146803727,"patch":[[{"diffs":[[0,"e;\n};\n\n\n"],[1,"\n"],[0,"var __up"]],"start1":7923,"start2":7923,"length1":16,"length2":17}]],"length":10575,"saved":false}
{"ts":1342147324107,"patch":[[{"diffs":[[0,"erties;\n"],[1,"  console.dir(meta);\n"],[0,"  meta.v"]],"start1":1950,"start2":1950,"length1":16,"length2":37}]],"length":10596,"saved":false}
{"ts":1342147338734,"patch":[[{"diffs":[[0,"ole.dir("],[-1,"meta"],[1,"options"],[0,");\n  met"]],"start1":1964,"start2":1964,"length1":20,"length2":23}]],"length":10599,"saved":false}
{"ts":1342147342212,"patch":[[{"diffs":[[0,"es;\n"],[-1,"  console.dir(options);\n"],[0,"  me"]],"start1":1954,"start2":1954,"length1":32,"length2":8}]],"length":10575,"saved":false}
{"contributors":[],"silentsave":true,"ts":1342892971007,"patch":[[{"diffs":[[0,"c');"],[-1,"\nvar crypto = require('crypto');\nvar traverse = require('traverse');"],[0,"\n\n/*"]],"start1":66,"start2":66,"length1":76,"length2":8},{"diffs":[[0," to "],[-1,"true.\n * @static\n */\nNohm.meta = true"],[1,"false, since it's a little faster.\n * @static\n */\nNohm.meta = false; // check if this should be defaulted to true.\nNohm.meta_saved_models = []"],[0,";\n\n/"]],"start1":807,"start2":807,"length1":45,"length2":150},{"diffs":[[0,"ions"],[-1,", temp) {\n  if ( ! name ) {\n    this.logError('When creating a new model you have to provide a name!');\n  }\n  "],[1,") {"],[0,"\n  v"]],"start1":1434,"start2":1434,"length1":118,"length2":11},{"diffs":[[0,"is.init("],[-1,""],[0,""],[1,"name, "],[0,"options)"]],"start1":1480,"start2":1480,"length1":16,"length2":22},{"diffs":[[0,"();\n"],[-1,"  \n  obj.prototype.modelName = name;\n\n  obj.prototype.idGenerator = options.idGenerator || 'default';\n  \n  var meta = {\n    inDb: false\n  };\n  meta.properties = options.properties;\n  meta.version = _meta_version(meta.properties, obj);\n  \n  obj.prototype.meta = meta;\n  "],[0,""],[1,""],[0,"\n  /"]],"start1":1709,"start2":1709,"length1":277,"length2":8},{"diffs":[[0,"};\n\n"],[-1,"  if ( ! temp) {\n  "],[0,"  mo"]],"start1":2354,"start2":2354,"length1":27,"length2":8},{"diffs":[[0,"] = obj;"],[-1,"\n  }"],[0,"\n\n  retu"]],"start1":2371,"start2":2371,"length1":20,"length2":16},{"diffs":[[0,"};\n\n"],[-1,"var _meta_version = function (properties, obj) {\n  var hash = crypto.createHash('sha1');\n  \n  hash.update(JSON.stringify(properties));\n  hash.update(JSON.stringify(obj.prototype.modelName));\n  hash.update(obj.prototype.idGenerator.toString());\n  \n  return hash.digest('hex');\n};\n\n"],[0,"/**\n"]],"start1":2395,"start2":2395,"length1":288,"length2":8},{"diffs":[[0,"nction ("],[1,"name, "],[0,"options)"]],"start1":5832,"start2":5832,"length1":16,"length2":22},{"diffs":[[0," options) {\n"],[1,"  if ( ! name ) {\n    this.logError('When creating a new model you have to provide a name!');\n  }\n\n"],[0,"  if (typeof"]],"start1":5845,"start2":5845,"length1":24,"length2":123},{"diffs":[[0,"odel: '+"],[-1,"this.modelN"],[1,"n"],[0,"ame);\n  "]],"start1":6098,"start2":6098,"length1":27,"length2":17},{"diffs":[[0,"\n  }"],[-1,"\n  \n  if ( ! this.meta.inDb) {\n    __updateMeta.call(this);\n  }"],[0,"\n\n  "]],"start1":6130,"start2":6130,"length1":71,"length2":8},{"diffs":[[0,"lient;\n  }\n\n"],[1,"  this.modelName = name;\n  this.idGenerator = options.idGenerator || 'default';\n\n"],[0,"  this.prope"]],"start1":6211,"start2":6211,"length1":24,"length2":105},{"diffs":[[0,") {\n"],[-1,"    \n"],[0,"    "]],"start1":6422,"start2":6422,"length1":13,"length2":8},{"diffs":[[0,"p] = [];"],[1,"\n\n        if ( Nohm.meta && ! Nohm.meta_saved_models.hasOwnProperty(this.modelName)) {\n          // try saving the meta data of this model\n          var metaargs = [Nohm.prefix.meta + this.modelName, p, JSON.stringify(this.properties[p])];\n          this.getClient().hmset(metaargs);\n        }"],[0,"\n      }"]],"start1":7096,"start2":7096,"length1":16,"length2":309},{"diffs":[[0,"  }\n  }\n"],[-1,"  "],[0,""],[1,""],[0,"\n  if (o"]],"start1":7408,"start2":7408,"length1":18,"length2":16},{"diffs":[[0,"alse"],[-1,";\n};\n\n\n\nvar __updateMeta = function () {\n  if ( ! Nohm.meta) {\n    return false;\n  }\n  var self = this;\n  \n  var version_key = Nohm.prefix.meta.version + this.modelName;\n  var idGenerator_key = Nohm.prefix.meta.idGenerator + this.modelName;\n  var properties_key = Nohm.prefix.meta.properties + this.modelName;\n  var properties = traverse(self.meta.properties).map(function (x) { \n    if (typeof x === 'function') {\n      return String(x) \n    } else {\n      return x;\n    }\n  });\n  \n  this.getClient().get(version_key, function (err, db_version) {\n    if (err) {\n      Nohm.logError(err);\n    } else if (self.meta.version !== db_version) {\n      async.parallel({\n        version: function (next) {\n          self.getClient().set(version_key, self.meta.version, next);\n        },\n        idGenerator: function (next) {\n          self.getClient().set(idGenerator_key, self.idGenerator.toString(), next);\n        },\n        properties: function (next) {\n          self.getClient().set(properties_key, JSON.stringify(properties), next);\n        }\n      }, function (err) {\n        if (err) {\n          Nohm.logError(err);\n        } else {\n          self.meta.inDb = true;\n        }\n      });\n    }\n  })"],[0,""],[1,""],[0,";\n};"]],"start1":7683,"start2":7683,"length1":1206,"length2":8}]],"length":9140,"saved":false}
