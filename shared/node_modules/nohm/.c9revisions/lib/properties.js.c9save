{"ts":1341350109437,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"var Nohm = null;\nexports.setNohm = function (originalNohm) {\n  Nohm = originalNohm;\n};\n\n/**\n *  Get or set a property.\n *  This automatically invokes typecasting and behaviours.\n */\nexports.property = function property(key, val) {\n  if (arguments.length > 2 || (typeof(key) === 'object' && typeof(val) === 'boolean')) {\n    // TODO: remove this warning\n    Nohm.logError('Deprecated: .property() does not support immediate validation anymore.');\n  }\n  var tmp;\n  var old;\n  var res = {};\n  var p;\n  if (typeof key === 'object') {\n    for (p in key) {\n      if (key.hasOwnProperty(p)) {\n        res[p] = this.p(p, key[p]);\n      }\n    }\n    return res;\n  }\n  if (!this.properties[key]) {\n    Nohm.logError('Trying to access undefined property \"'+key+\n      '\" of object \"'+this.modelName+'\" with id:'+this.id+'.');\n    return false;\n  }\n  tmp = this.properties[key];\n  if (typeof val === 'undefined') {\n    return tmp.type === 'json' ? JSON.parse(tmp.value) : tmp.value;\n  } else if (val !== tmp.value) {\n    tmp = this.properties[key];\n    old = tmp.value;\n    tmp.value = this.__cast(key, val, old);\n    tmp.__updated = tmp.value !== tmp.__oldValue;\n  }\n  return tmp.value;\n};\n\n/**\n * Alias for Nohm.property()\n * @name p\n * @methodOf Nohm\n * @see Nohm.property\n */\n\n/**\n * Alias for Nohm.property()\n * @name prop\n * @methodOf Nohm\n * @see Nohm.property\n */\nexports.p = exports.prop = exports.property;\n\n/**\n * Resets the property meta data. Should be called internally after saving.\n */\nexports.__resetProp = function resetProp(p) {\n  var tmp = this.properties[p];\n  tmp.__updated = false;\n  tmp.__oldValue = tmp.value;\n  tmp.__numericIndex = Nohm.indexNumberTypes.indexOf(tmp.type) > -1 && !tmp.noscore;\n};\n\n/**\n   *  Casts a property to a certain datatype. (Might cause unexpected results.\n   *  Behaviours offer greater control over what happens.)\n   *  Currently supported:\n   *  string,\n   *  integer,\n   *  float,\n   *  timestamp (time/date string or number to unix timestamp),\n   *  json\n   */\nexports.__cast = function __cast(key, value, old) {\n  if (!this.properties[key]) {\n    Nohm.logError('Trying to access undefined property \"' +\n    key + '\" of object \"' + this.modelName + '\".');\n    return false;\n  }\n  var type = this.properties[key].type,\n    timezoneOffset,\n    matches,\n    hours,\n    minutes;\n    \n  if (typeof (type) === 'undefined') {\n    return value;\n  }\n\n  if (typeof (type) === 'function') {\n    return type.call(this, value, key, old);\n  }\n  \n  switch (type.toLowerCase()) {\n  case 'boolean':\n  case 'bool':\n    return value === 'false' ? false : !!value;\n  case 'string':\n  case 'string':\n    // no .toString() here. TODO: or should there be?\n    return (\n            (!(value instanceof String) ||\n             value.toString() === '') && typeof value !== 'string'\n            ) ? ''\n              : value;\n  case 'integer':\n  case 'int':\n    return isNaN(parseInt(value, 10)) ? 0 : parseInt(value, 10);\n  case 'float':\n    return isNaN(parseFloat(value)) ? 0 : parseFloat(value);\n  case 'date':\n  case 'time':\n  case 'timestamp':\n    // make it a timestamp aka. miliseconds from 1970\n    if (isNaN(value) && typeof value === 'string') {\n      // see if there is a timezone specified in the string\n      matches = value.match(/(\\+|\\-)([\\d]{1,2})\\:([\\d]{2})$/);\n      if (value.match(/Z$/)) {\n        // UTC timezone in an ISO string (hopefully)\n        timezoneOffset = 0;\n      } else if (matches) {\n        // +/- hours:minutes specified.\n        // calculating offsets in minutes and removing the offset from the string since new Date() can't handle those.\n        hours = parseInt(matches[2], 10);\n        minutes = parseInt(matches[3], 10);\n        if (matches[1] === '-') {\n          timezoneOffset = -1 * (hours * 60 + minutes);\n        } else {\n          timezoneOffset = hours * 60 - minutes;\n        }\n        value = value.substring(0, value.length - matches[0].length);\n      } else {\n        timezoneOffset = new Date(value).getTimezoneOffset();\n      }\n      return new Date(value).getTime() - timezoneOffset * 60 * 1000;\n    }\n    return parseInt(value, 10);\n  case 'json':\n    if (typeof (value) === 'object') {\n      return JSON.stringify(value);\n    } else {\n      try {\n        // already is json, do nothing\n        JSON.parse(value);\n        return value;\n      } catch (e) {\n        return JSON.stringify(value);\n      }\n    }\n  default:\n    return value;\n  }\n};\n\n/**\n * Get an array of all properties that have been changed.\n */\nexports.propertyDiff = function propertyDiff(key) {\n  var diff = [],\n  p;\n  if (key && !this.properties[key]) {\n    throw 'Invalid key specified for diffProperty';\n  }\n\n  for (p in this.properties) {\n    if (!key || p === key) {\n      if (this.properties[p].__updated) {\n        diff.push({\n          key: p,\n          before: this.properties[p].__oldValue,\n          after: this.properties[p].value\n        });\n      }\n    }\n  }\n  return diff;\n};\n\n/**\n *  Resets the values of all or one propert(y/ies).\n */\nexports.propertyReset = function propertyReset(key) {\n  if (key && !this.properties[key]) {\n    throw 'Invalid key specified for diffProperty';\n  }\n\n  for (var p in this.properties) {\n    if (!key || p === key) {\n      this.properties[p].__updated = false;\n      this.properties[p].value = this.properties[p].__oldValue;\n    }\n  }\n  return true;\n};\n\n/**\n *  Get all properties with values either as an array or as json (param true)\n */\nexports.allProperties = function allProperties(json) {\n  var props = {},\n  p;\n  for (p in this.properties) {\n    if (this.properties.hasOwnProperty(p)) {\n      props[p] = this.p(p);\n    }\n  }\n  props.id = this.id;\n  return json ? JSON.stringify(props) : props;\n};"]],"start1":0,"start2":0,"length1":0,"length2":5693}]],"length":5693}
