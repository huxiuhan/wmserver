{"ts":1341349625171,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*global Buffer require exports console setTimeout */\n\nvar net = require(\"net\"),\n    util = require(\"./lib/util\"),\n    Queue = require(\"./lib/queue\"),\n    to_array = require(\"./lib/to_array\"),\n    events = require(\"events\"),\n    parsers = [], commands,\n    connection_id = 0,\n    default_port = 6379,\n    default_host = \"127.0.0.1\";\n\n// can set this to true to enable for all connections\nexports.debug_mode = false;\n\n// hiredis might not be installed\ntry {\n    require(\"./lib/parser/hiredis\");\n    parsers.push(require(\"./lib/parser/hiredis\"));\n} catch (err) {\n    if (exports.debug_mode) {\n        console.warn(\"hiredis parser not installed.\");\n    }\n}\n\nparsers.push(require(\"./lib/parser/javascript\"));\n\nfunction RedisClient(stream, options) {\n    this.stream = stream;\n    this.options = options = options || {};\n\n    this.connection_id = ++connection_id;\n    this.connected = false;\n    this.ready = false;\n    this.connections = 0;\n    if (this.options.socket_nodelay === undefined) {\n        this.options.socket_nodelay = true;\n    }\n    this.should_buffer = false;\n    this.command_queue_high_water = this.options.command_queue_high_water || 1000;\n    this.command_queue_low_water = this.options.command_queue_low_water || 0;\n    this.max_attempts = null;\n    if (options.max_attempts && !isNaN(options.max_attempts) && options.max_attempts > 0) {\n        this.max_attempts = +options.max_attempts;\n    }\n    this.command_queue = new Queue(); // holds sent commands to de-pipeline them\n    this.offline_queue = new Queue(); // holds commands issued but not able to be sent\n    this.commands_sent = 0;\n    this.connect_timeout = false;\n    if (options.connect_timeout && !isNaN(options.connect_timeout) && options.connect_timeout > 0) {\n        this.connect_timeout = +options.connect_timeout;\n    }\n    this.initialize_retry_vars();\n    this.pub_sub_mode = false;\n    this.subscription_set = {};\n    this.monitoring = false;\n    this.closing = false;\n    this.server_info = {};\n    this.auth_pass = null;\n    this.parser_module = null;\n    this.selected_db = null;\t// save the selected db here, used when reconnecting\n\t\n    var self = this;\n\n    this.stream.on(\"connect\", function () {\n        self.on_connect();\n    });\n\n    this.stream.on(\"data\", function (buffer_from_socket) {\n        self.on_data(buffer_from_socket);\n    });\n\n    this.stream.on(\"error\", function (msg) {\n        self.on_error(msg.message);\n    });\n\n    this.stream.on(\"close\", function () {\n        self.connection_gone(\"close\");\n    });\n\n    this.stream.on(\"end\", function () {\n        self.connection_gone(\"end\");\n    });\n\n    this.stream.on(\"drain\", function () {\n        self.should_buffer = false;\n        self.emit(\"drain\");\n    });\n\n    events.EventEmitter.call(this);\n}\nutil.inherits(RedisClient, events.EventEmitter);\nexports.RedisClient = RedisClient;\n\nRedisClient.prototype.initialize_retry_vars = function () {\n    this.retry_timer = null;\n    this.retry_totaltime = 0;\n    this.retry_delay = 150;\n    this.retry_backoff = 1.7;\n    this.attempts = 1;\n};\n\n// flush offline_queue and command_queue, erroring any items with a callback first\nRedisClient.prototype.flush_and_error = function (message) {\n    var command_obj;\n    while (this.offline_queue.length > 0) {\n        command_obj = this.offline_queue.shift();\n        if (typeof command_obj.callback === \"function\") {\n            command_obj.callback(message);\n        }\n    }\n    this.offline_queue = new Queue();\n\n    while (this.command_queue.length > 0) {\n        command_obj = this.command_queue.shift();\n        if (typeof command_obj.callback === \"function\") {\n            command_obj.callback(message);\n        }\n    }\n    this.command_queue = new Queue();\n};\n\nRedisClient.prototype.on_error = function (msg) {\n    var message = \"Redis connection to \" + this.host + \":\" + this.port + \" failed - \" + msg,\n        self = this, command_obj;\n\n    if (this.closing) {\n        return;\n    }\n\n    if (exports.debug_mode) {\n        console.warn(message);\n    }\n\n    this.flush_and_error(message);\n\n    this.connected = false;\n    this.ready = false;\n\n    this.emit(\"error\", new Error(message));\n    // \"error\" events get turned into exceptions if they aren't listened for.  If the user handled this error\n    // then we should try to reconnect.\n    this.connection_gone(\"error\");\n};\n\nRedisClient.prototype.do_auth = function () {\n    var self = this;\n\n    if (exports.debug_mode) {\n        console.log(\"Sending auth to \" + self.host + \":\" + self.port + \" id \" + self.connection_id);\n    }\n    self.send_anyway = true;\n    self.send_command(\"auth\", [this.auth_pass], function (err, res) {\n        if (err) {\n            if (err.toString().match(\"LOADING\")) {\n                // if redis is still loading the db, it will not authenticate and everything else will fail\n                console.log(\"Redis still loading, trying to authenticate later\");\n                setTimeout(function () {\n                    self.do_auth();\n                }, 2000); // TODO - magic number alert\n                return;\n            } else {\n                return self.emit(\"error\", new Error(\"Auth error: \" + err.message));\n            }\n        }\n        if (res.toString() !== \"OK\") {\n            return self.emit(\"error\", new Error(\"Auth failed: \" + res.toString()));\n        }\n        if (exports.debug_mode) {\n            console.log(\"Auth succeeded \" + self.host + \":\" + self.port + \" id \" + self.connection_id);\n        }\n        if (self.auth_callback) {\n            self.auth_callback(err, res);\n            self.auth_callback = null;\n        }\n\n        // now we are really connected\n        self.emit(\"connect\");\n        if (self.options.no_ready_check) {\n            self.on_ready();\n        } else {\n            self.ready_check();\n        }\n    });\n    self.send_anyway = false;\n};\n\nRedisClient.prototype.on_connect = function () {\n    if (exports.debug_mode) {\n        console.log(\"Stream connected \" + this.host + \":\" + this.port + \" id \" + this.connection_id);\n    }\n    var self = this;\n\n    this.connected = true;\n    this.ready = false;\n    this.attempts = 0;\n    this.connections += 1;\n    this.command_queue = new Queue();\n    this.emitted_end = false;\n    this.initialize_retry_vars();\n    if (this.options.socket_nodelay) {\n        this.stream.setNoDelay();\n    }\n    this.stream.setTimeout(0);\n\n    this.init_parser();\n\n    if (this.auth_pass) {\n        this.do_auth();\n    } else {\n        this.emit(\"connect\");\n\n        if (this.options.no_ready_check) {\n            this.on_ready();\n        } else {\n            this.ready_check();\n        }\n    }\n};\n\nRedisClient.prototype.init_parser = function () {\n    var self = this;\n\n    if (this.options.parser) {\n        if (! parsers.some(function (parser) {\n            if (parser.name === self.options.parser) {\n                self.parser_module = parser;\n                if (exports.debug_mode) {\n                    console.log(\"Using parser module: \" + self.parser_module.name);\n                }\n                return true;\n            }\n        })) {\n            throw new Error(\"Couldn't find named parser \" + self.options.parser + \" on this system\");\n        }\n    } else {\n        if (exports.debug_mode) {\n            console.log(\"Using default parser module: \" + parsers[0].name);\n        }\n        this.parser_module = parsers[0];\n    }\n\n    this.parser_module.debug_mode = exports.debug_mode;\n\n    // return_buffers sends back Buffers from parser to callback. detect_buffers sends back Buffers from parser, but\n    // converts to Strings if the input arguments are not Buffers.\n    this.reply_parser = new this.parser_module.Parser({\n        return_buffers: self.options.return_buffers || self.options.detect_buffers || false\n    });\n\n    // \"reply error\" is an error sent back by Redis\n    this.reply_parser.on(\"reply error\", function (reply) {\n        self.return_error(new Error(reply));\n    });\n    this.reply_parser.on(\"reply\", function (reply) {\n        self.return_reply(reply);\n    });\n    // \"error\" is bad.  Somehow the parser got confused.  It'll try to reset and continue.\n    this.reply_parser.on(\"error\", function (err) {\n        self.emit(\"error\", new Error(\"Redis reply parser error: \" + err.stack));\n    });\n};\n\nRedisClient.prototype.on_ready = function () {\n    var self = this;\n\n    this.ready = true;\n\n    // magically restore any modal commands from a previous connection\n    if (this.selected_db !== null) {\n        this.send_command('select', [this.selected_db]);\n    }\n    if (this.pub_sub_mode === true) {\n        Object.keys(this.subscription_set).forEach(function (key) {\n            var parts = key.split(\" \");\n            if (exports.debug_mode) {\n                console.warn(\"sending pub/sub on_ready \" + parts[0] + \", \" + parts[1]);\n            }\n            self.send_command(parts[0], [parts[1]]);\n        });\n    } else if (this.monitoring) {\n        this.send_command(\"monitor\");\n    } else {\n        this.send_offline_queue();\n    }\n    this.emit(\"ready\");\n};\n\nRedisClient.prototype.on_info_cmd = function (err, res) {\n    var self = this, obj = {}, lines, retry_time;\n\n    if (err) {\n        return self.emit(\"error\", new Error(\"Ready check failed: \" + err.message));\n    }\n\n    lines = res.toString().split(\"\\r\\n\");\n\n    lines.forEach(function (line) {\n        var parts = line.split(':');\n        if (parts[1]) {\n            obj[parts[0]] = parts[1];\n        }\n    });\n\n    obj.versions = [];\n    obj.redis_version.split('.').forEach(function (num) {\n        obj.versions.push(+num);\n    });\n\n    // expose info key/vals to users\n    this.server_info = obj;\n\n    if (!obj.loading || (obj.loading && obj.loading === \"0\")) {\n        if (exports.debug_mode) {\n            console.log(\"Redis server ready.\");\n        }\n        this.on_ready();\n    } else {\n        retry_time = obj.loading_eta_seconds * 1000;\n        if (retry_time > 1000) {\n            retry_time = 1000;\n        }\n        if (exports.debug_mode) {\n            console.log(\"Redis server still loading, trying again in \" + retry_time);\n        }\n        setTimeout(function () {\n            self.ready_check();\n        }, retry_time);\n    }\n};\n\nRedisClient.prototype.ready_check = function () {\n    var self = this;\n\n    if (exports.debug_mode) {\n        console.log(\"checking server ready state...\");\n    }\n\n    this.send_anyway = true;  // secret flag to send_command to send something even if not \"ready\"\n    this.info(function (err, res) {\n        self.on_info_cmd(err, res);\n    });\n    this.send_anyway = false;\n};\n\nRedisClient.prototype.send_offline_queue = function () {\n    var command_obj, buffered_writes = 0;\n\n    while (this.offline_queue.length > 0) {\n        command_obj = this.offline_queue.shift();\n        if (exports.debug_mode) {\n            console.log(\"Sending offline command: \" + command_obj.command);\n        }\n        buffered_writes += !this.send_command(command_obj.command, command_obj.args, command_obj.callback);\n    }\n    this.offline_queue = new Queue();\n    // Even though items were shifted off, Queue backing store still uses memory until next add, so just get a new Queue\n\n    if (!buffered_writes) {\n        this.should_buffer = false;\n        this.emit(\"drain\");\n    }\n};\n\nRedisClient.prototype.connection_gone = function (why) {\n    var self = this, message;\n\n    // If a retry is already in progress, just let that happen\n    if (this.retry_timer) {\n        return;\n    }\n\n    if (exports.debug_mode) {\n        console.warn(\"Redis connection is gone from \" + why + \" event.\");\n    }\n    this.connected = false;\n    this.ready = false;\n\n    // since we are collapsing end and close, users don't expect to be called twice\n    if (! this.emitted_end) {\n        this.emit(\"end\");\n        this.emitted_end = true;\n    }\n\n    this.flush_and_error(\"Redis connection gone from \" + why + \" event.\");\n\n    // If this is a requested shutdown, then don't retry\n    if (this.closing) {\n        this.retry_timer = null;\n        if (exports.debug_mode) {\n            console.warn(\"connection ended from quit command, not retrying.\");\n        }\n        return;\n    }\n\n    this.retry_delay = Math.floor(this.retry_delay * this.retry_backoff);\n\n    if (exports.debug_mode) {\n        console.log(\"Retry connection in \" + this.current_retry_delay + \" ms\");\n    }\n\n    if (this.max_attempts && this.attempts >= this.max_attempts) {\n        this.retry_timer = null;\n        // TODO - some people need a \"Redis is Broken mode\" for future commands that errors immediately, and others\n        // want the program to exit.  Right now, we just log, which doesn't really help in either case.\n        console.error(\"node_redis: Couldn't get Redis connection after \" + this.max_attempts + \" attempts.\");\n        return;\n    }\n\n    this.attempts += 1;\n    this.emit(\"reconnecting\", {\n        delay: self.retry_delay,\n        attempt: self.attempts\n    });\n    this.retry_timer = setTimeout(function () {\n        if (exports.debug_mode) {\n            console.log(\"Retrying connection...\");\n        }\n\n        self.retry_totaltime += self.current_retry_delay;\n\n        if (self.connect_timeout && self.retry_totaltime >= self.connect_timeout) {\n            self.retry_timer = null;\n            // TODO - engage Redis is Broken mode for future commands, or whatever\n            console.error(\"node_redis: Couldn't get Redis connection after \" + self.retry_totaltime + \"ms.\");\n            return;\n        }\n\n        self.stream.connect(self.port, self.host);\n        self.retry_timer = null;\n    }, this.retry_delay);\n};\n\nRedisClient.prototype.on_data = function (data) {\n    if (exports.debug_mode) {\n        console.log(\"net read \" + this.host + \":\" + this.port + \" id \" + this.connection_id + \": \" + data.toString());\n    }\n\n    try {\n        this.reply_parser.execute(data);\n    } catch (err) {\n        // This is an unexpected parser problem, an exception that came from the parser code itself.\n        // Parser should emit \"error\" events if it notices things are out of whack.\n        // Callbacks that throw exceptions will land in return_reply(), below.\n        // TODO - it might be nice to have a different \"error\" event for different types of errors\n        this.emit(\"error\", err);\n    }\n};\n\nRedisClient.prototype.return_error = function (err) {\n    var command_obj = this.command_queue.shift(), queue_len = this.command_queue.getLength();\n\n    if (this.pub_sub_mode === false && queue_len === 0) {\n        this.emit(\"idle\");\n        this.command_queue = new Queue();\n    }\n    if (this.should_buffer && queue_len <= this.command_queue_low_water) {\n        this.emit(\"drain\");\n        this.should_buffer = false;\n    }\n\n    if (command_obj && typeof command_obj.callback === \"function\") {\n        try {\n            command_obj.callback(err);\n        } catch (callback_err) {\n            // if a callback throws an exception, re-throw it on a new stack so the parser can keep going\n            process.nextTick(function () {\n                throw callback_err;\n            });\n        }\n    } else {\n        console.log(\"node_redis: no callback to send error: \" + err.message);\n        // this will probably not make it anywhere useful, but we might as well throw\n        process.nextTick(function () {\n            throw err;\n        });\n    }\n};\n\n// if a callback throws an exception, re-throw it on a new stack so the parser can keep going.\n// put this try/catch in its own function because V8 doesn't optimize this well yet.\nfunction try_callback(callback, reply) {\n    try {\n        callback(null, reply);\n    } catch (err) {\n        process.nextTick(function () {\n            throw err;\n        });\n    }\n}\n\n// hgetall converts its replies to an Object.  If the reply is empty, null is returned.\nfunction reply_to_object(reply) {\n    var obj = {}, j, jl, key, val;\n\n    if (reply.length === 0) {\n        return null;\n    }\n\n    for (j = 0, jl = reply.length; j < jl; j += 2) {\n        key = reply[j].toString();\n        val = reply[j + 1];\n        obj[key] = val;\n    }\n\n    return obj;\n}\n\nfunction reply_to_strings(reply) {\n    var i;\n\n    if (Buffer.isBuffer(reply)) {\n        return reply.toString();\n    }\n\n    if (Array.isArray(reply)) {\n        for (i = 0; i < reply.length; i++) {\n            reply[i] = reply[i].toString();\n        }\n        return reply;\n    }\n\n    return reply;\n}\n\nRedisClient.prototype.return_reply = function (reply) {\n    var command_obj, obj, i, len, type, timestamp, argindex, args, queue_len;\n    \n    queue_len = this.command_queue.getLength();\n\n    if (this.pub_sub_mode === false && queue_len === 0) {\n        this.emit(\"idle\");\n        this.command_queue = new Queue();  // explicitly reclaim storage from old Queue\n    }\n    if (this.should_buffer && queue_len <= this.command_queue_low_water) {\n        this.emit(\"drain\");\n        this.should_buffer = false;\n    }\n\n    command_obj = this.command_queue.shift();\n\n    if (command_obj && !command_obj.sub_command) {\n        if (typeof command_obj.callback === \"function\") {\n            if (this.options.detect_buffers && command_obj.buffer_args === false) {\n                // If detect_buffers option was specified, then the reply from the parser will be Buffers.\n                // If this command did not use Buffer arguments, then convert the reply to Strings here.\n                reply = reply_to_strings(reply);\n            }\n\n            // TODO - confusing and error-prone that hgetall is special cased in two places\n            if (reply && 'hgetall' === command_obj.command.toLowerCase()) {\n                reply = reply_to_object(reply);\n            }\n\n            try_callback(command_obj.callback, reply);\n        } else if (exports.debug_mode) {\n            console.log(\"no callback for reply: \" + (reply && reply.toString && reply.toString()));\n        }\n    } else if (this.pub_sub_mode || (command_obj && command_obj.sub_command)) {\n        if (Array.isArray(reply)) {\n            type = reply[0].toString();\n\n            if (type === \"message\") {\n                this.emit(\"message\", reply[1].toString(), reply[2]); // channel, message\n            } else if (type === \"pmessage\") {\n                this.emit(\"pmessage\", reply[1].toString(), reply[2].toString(), reply[3]); // pattern, channel, message\n            } else if (type === \"subscribe\" || type === \"unsubscribe\" || type === \"psubscribe\" || type === \"punsubscribe\") {\n                if (reply[2] === 0) {\n                    this.pub_sub_mode = false;\n                    if (this.debug_mode) {\n                        console.log(\"All subscriptions removed, exiting pub/sub mode\");\n                    }\n                } else {\n                    this.pub_sub_mode = true;\n                }\n                // subscribe commands take an optional callback and also emit an event, but only the first response is included in the callback\n                // TODO - document this or fix it so it works in a more obvious way\n                if (command_obj && typeof command_obj.callback === \"function\") {\n                    try_callback(command_obj.callback, reply[1].toString());\n                }\n                this.emit(type, reply[1].toString(), reply[2]); // channel, count\n            } else {\n                throw new Error(\"subscriptions are active but got unknown reply type \" + type);\n            }\n        } else if (! this.closing) {\n            throw new Error(\"subscriptions are active but got an invalid reply: \" + reply);\n        }\n    } else if (this.monitoring) {\n        len = reply.indexOf(\" \");\n        timestamp = reply.slice(0, len);\n        argindex = reply.indexOf('\"');\n        args = reply.slice(argindex + 1, -1).split('\" \"').map(function (elem) {\n            return elem.replace(/\\\\\"/g, '\"');\n        });\n        this.emit(\"monitor\", timestamp, args);\n    } else {\n        throw new Error(\"node_redis command queue state error. If you can reproduce this, please report it.\");\n    }\n};\n\n// This Command constructor is ever so slightly faster than using an object literal, but more importantly, using\n// a named constructor helps it show up meaningfully in the V8 CPU profiler and in heap snapshots.\nfunction Command(command, args, sub_command, buffer_args, callback) {\n    this.command = command;\n    this.args = args;\n    this.sub_command = sub_command;\n    this.buffer_args = buffer_args;\n    this.callback = callback;\n}\n\nRedisClient.prototype.send_command = function (command, args, callback) {\n    var arg, this_args, command_obj, i, il, elem_count, buffer_args, stream = this.stream, command_str = \"\", buffered_writes = 0, last_arg_type;\n\n    if (typeof command !== \"string\") {\n        throw new Error(\"First argument to send_command must be the command name string, not \" + typeof command);\n    }\n\n    if (Array.isArray(args)) {\n        if (typeof callback === \"function\") {\n            // probably the fastest way:\n            //     client.command([arg1, arg2], cb);  (straight passthrough)\n            //         send_command(command, [arg1, arg2], cb);\n        } else if (! callback) {\n            // most people find this variable argument length form more convenient, but it uses arguments, which is slower\n            //     client.command(arg1, arg2, cb);   (wraps up arguments into an array)\n            //       send_command(command, [arg1, arg2, cb]);\n            //     client.command(arg1, arg2);   (callback is optional)\n            //       send_command(command, [arg1, arg2]);\n            //     client.command(arg1, arg2, undefined);   (callback is undefined)\n            //       send_command(command, [arg1, arg2, undefined]);\n            last_arg_type = typeof args[args.length - 1];\n            if (last_arg_type === \"function\" || last_arg_type === \"undefined\") {\n                callback = args.pop();\n            }\n        } else {\n            throw new Error(\"send_command: last argument must be a callback or undefined\");\n        }\n    } else {\n        throw new Error(\"send_command: second argument must be an array\");\n    }\n\n    // if the last argument is an array, expand it out.  This allows commands like this:\n    //     client.command(arg1, [arg2, arg3, arg4], cb);\n    //  and converts to:\n    //     client.command(arg1, arg2, arg3, arg4, cb);\n    // which is convenient for some things like sadd\n    if (args.length > 0 && Array.isArray(args[args.length - 1])) {\n        args = args.slice(0, -1).concat(args[args.length - 1]);\n    }\n\n    buffer_args = false;\n    for (i = 0, il = args.length, arg; i < il; i += 1) {\n        if (Buffer.isBuffer(args[i])) {\n            buffer_args = true;\n        }\n    }\n\n    command_obj = new Command(command, args, false, buffer_args, callback);\n\n    if ((!this.ready && !this.send_anyway) || !stream.writable) {\n        if (exports.debug_mode) {\n            if (!stream.writable) {\n                console.log(\"send command: stream is not writeable.\");\n            }\n            \n            console.log(\"Queueing \" + command + \" for next server connection.\");\n        }\n        this.offline_queue.push(command_obj);\n        this.should_buffer = true;\n        return false;\n    }\n\n    if (command === \"subscribe\" || command === \"psubscribe\" || command === \"unsubscribe\" || command === \"punsubscribe\") {\n        this.pub_sub_command(command_obj);\n    } else if (command === \"monitor\") {\n        this.monitoring = true;\n    } else if (command === \"quit\") {\n        this.closing = true;\n    } else if (this.pub_sub_mode === true) {\n        throw new Error(\"Connection in pub/sub mode, only pub/sub commands may be used\");\n    }\n    this.command_queue.push(command_obj);\n    this.commands_sent += 1;\n\n    elem_count = args.length + 1;\n\n    // Always use \"Multi bulk commands\", but if passed any Buffer args, then do multiple writes, one for each arg.\n    // This means that using Buffers in commands is going to be slower, so use Strings if you don't already have a Buffer.\n\n    command_str = \"*\" + elem_count + \"\\r\\n$\" + command.length + \"\\r\\n\" + command + \"\\r\\n\";\n\n    if (! buffer_args) { // Build up a string and send entire command in one write\n        for (i = 0, il = args.length, arg; i < il; i += 1) {\n            arg = args[i];\n            if (typeof arg !== \"string\") {\n                arg = String(arg);\n            }\n            command_str += \"$\" + Buffer.byteLength(arg) + \"\\r\\n\" + arg + \"\\r\\n\";\n        }\n        if (exports.debug_mode) {\n            console.log(\"send \" + this.host + \":\" + this.port + \" id \" + this.connection_id + \": \" + command_str);\n        }\n        buffered_writes += !stream.write(command_str);\n    } else {\n        if (exports.debug_mode) {\n            console.log(\"send command (\" + command_str + \") has Buffer arguments\");\n        }\n        buffered_writes += !stream.write(command_str);\n\n        for (i = 0, il = args.length, arg; i < il; i += 1) {\n            arg = args[i];\n            if (!(Buffer.isBuffer(arg) || arg instanceof String)) {\n                arg = String(arg);\n            }\n\n            if (Buffer.isBuffer(arg)) {\n                if (arg.length === 0) {\n                    if (exports.debug_mode) {\n                        console.log(\"send_command: using empty string for 0 length buffer\");\n                    }\n                    buffered_writes += !stream.write(\"$0\\r\\n\\r\\n\");\n                } else {\n                    buffered_writes += !stream.write(\"$\" + arg.length + \"\\r\\n\");\n                    buffered_writes += !stream.write(arg);\n                    buffered_writes += !stream.write(\"\\r\\n\");\n                    if (exports.debug_mode) {\n                        console.log(\"send_command: buffer send \" + arg.length + \" bytes\");\n                    }\n                }\n            } else {\n                if (exports.debug_mode) {\n                    console.log(\"send_command: string send \" + Buffer.byteLength(arg) + \" bytes: \" + arg);\n                }\n                buffered_writes += !stream.write(\"$\" + Buffer.byteLength(arg) + \"\\r\\n\" + arg + \"\\r\\n\");\n            }\n        }\n    }\n    if (exports.debug_mode) {\n        console.log(\"send_command buffered_writes: \" + buffered_writes, \" should_buffer: \" + this.should_buffer);\n    }\n    if (buffered_writes || this.command_queue.getLength() >= this.command_queue_high_water) {\n        this.should_buffer = true;\n    }\n    return !this.should_buffer;\n};\n\nRedisClient.prototype.pub_sub_command = function (command_obj) {\n    var i, key, command, args;\n    \n    if (this.pub_sub_mode === false && exports.debug_mode) {\n        console.log(\"Entering pub/sub mode from \" + command_obj.command);\n    }\n    this.pub_sub_mode = true;\n    command_obj.sub_command = true;\n\n    command = command_obj.command;\n    args = command_obj.args;\n    if (command === \"subscribe\" || command === \"psubscribe\") {\n        if (command === \"subscribe\") {\n            key = \"sub\";\n        } else {\n            key = \"psub\";\n        }\n        for (i = 0; i < args.length; i++) {\n            this.subscription_set[key + \" \" + args[i]] = true;\n        }\n    } else {\n        if (command === \"unsubscribe\") {\n            key = \"sub\";\n        } else {\n            key = \"psub\";\n        }\n        for (i = 0; i < args.length; i++) {\n            delete this.subscription_set[key + \" \" + args[i]];\n        }\n    }\n};\n\nRedisClient.prototype.end = function () {\n    this.stream._events = {};\n    this.connected = false;\n    this.ready = false;\n    return this.stream.end();\n};\n\nfunction Multi(client, args) {\n    this.client = client;\n    this.queue = [[\"MULTI\"]];\n    if (Array.isArray(args)) {\n        this.queue = this.queue.concat(args);\n    }\n}\n\nexports.Multi = Multi;\n\n// take 2 arrays and return the union of their elements\nfunction set_union(seta, setb) {\n    var obj = {};\n    \n    seta.forEach(function (val) {\n        obj[val] = true;\n    });\n    setb.forEach(function (val) {\n        obj[val] = true;\n    });\n    return Object.keys(obj);\n}\n\n// This static list of commands is updated from time to time.  ./lib/commands.js can be updated with generate_commands.js\ncommands = set_union([\"get\", \"set\", \"setnx\", \"setex\", \"append\", \"strlen\", \"del\", \"exists\", \"setbit\", \"getbit\", \"setrange\", \"getrange\", \"substr\",\n    \"incr\", \"decr\", \"mget\", \"rpush\", \"lpush\", \"rpushx\", \"lpushx\", \"linsert\", \"rpop\", \"lpop\", \"brpop\", \"brpoplpush\", \"blpop\", \"llen\", \"lindex\",\n    \"lset\", \"lrange\", \"ltrim\", \"lrem\", \"rpoplpush\", \"sadd\", \"srem\", \"smove\", \"sismember\", \"scard\", \"spop\", \"srandmember\", \"sinter\", \"sinterstore\",\n    \"sunion\", \"sunionstore\", \"sdiff\", \"sdiffstore\", \"smembers\", \"zadd\", \"zincrby\", \"zrem\", \"zremrangebyscore\", \"zremrangebyrank\", \"zunionstore\",\n    \"zinterstore\", \"zrange\", \"zrangebyscore\", \"zrevrangebyscore\", \"zcount\", \"zrevrange\", \"zcard\", \"zscore\", \"zrank\", \"zrevrank\", \"hset\", \"hsetnx\",\n    \"hget\", \"hmset\", \"hmget\", \"hincrby\", \"hdel\", \"hlen\", \"hkeys\", \"hvals\", \"hgetall\", \"hexists\", \"incrby\", \"decrby\", \"getset\", \"mset\", \"msetnx\",\n    \"randomkey\", \"select\", \"move\", \"rename\", \"renamenx\", \"expire\", \"expireat\", \"keys\", \"dbsize\", \"auth\", \"ping\", \"echo\", \"save\", \"bgsave\",\n    \"bgrewriteaof\", \"shutdown\", \"lastsave\", \"type\", \"multi\", \"exec\", \"discard\", \"sync\", \"flushdb\", \"flushall\", \"sort\", \"info\", \"monitor\", \"ttl\",\n    \"persist\", \"slaveof\", \"debug\", \"config\", \"subscribe\", \"unsubscribe\", \"psubscribe\", \"punsubscribe\", \"publish\", \"watch\", \"unwatch\", \"cluster\",\n    \"restore\", \"migrate\", \"dump\", \"object\", \"client\", \"eval\", \"evalsha\"], require(\"./lib/commands\"));\n\ncommands.forEach(function (command) {\n    RedisClient.prototype[command] = function (args, callback) {\n        if (Array.isArray(args) && typeof callback === \"function\") {\n            return this.send_command(command, args, callback);\n        } else {\n            return this.send_command(command, to_array(arguments));\n        }\n    };\n    RedisClient.prototype[command.toUpperCase()] = RedisClient.prototype[command];\n\n    Multi.prototype[command] = function () {\n        this.queue.push([command].concat(to_array(arguments)));\n        return this;\n    };\n    Multi.prototype[command.toUpperCase()] = Multi.prototype[command];\n});\n\n// store db in this.select_db to restore it on reconnect\nRedisClient.prototype.select = function (db, callback) {\n\tvar self = this;\n\n\tthis.send_command('select', [db], function (err, res) {\n        if (err === null) {\n            self.selected_db = db;\n        }\n        if (typeof(callback) === 'function') {\n            callback(err, res);\n        }\n    });\n};\nRedisClient.prototype.SELECT = RedisClient.prototype.select;\n\n// Stash auth for connect and reconnect.  Send immediately if already connected.\nRedisClient.prototype.auth = function () {\n    var args = to_array(arguments);\n    this.auth_pass = args[0];\n    this.auth_callback = args[1];\n    if (exports.debug_mode) {\n        console.log(\"Saving auth as \" + this.auth_pass);\n    }\n\n    if (this.connected) {\n        this.send_command(\"auth\", args);\n    }\n};\nRedisClient.prototype.AUTH = RedisClient.prototype.auth;\n\nRedisClient.prototype.hmget = function (arg1, arg2, arg3) {\n    if (Array.isArray(arg2) && typeof arg3 === \"function\") {\n        return this.send_command(\"hmget\", [arg1].concat(arg2), arg3);\n    } else if (Array.isArray(arg1) && typeof arg2 === \"function\") {\n        return this.send_command(\"hmget\", arg1, arg2);\n    } else {\n        return this.send_command(\"hmget\", to_array(arguments));\n    }\n};\nRedisClient.prototype.HMGET = RedisClient.prototype.hmget;\n\nRedisClient.prototype.hmset = function (args, callback) {\n    var tmp_args, tmp_keys, i, il, key;\n\n    if (Array.isArray(args) && typeof callback === \"function\") {\n        return this.send_command(\"hmset\", args, callback);\n    }\n\n    args = to_array(arguments);\n    if (typeof args[args.length - 1] === \"function\") {\n        callback = args[args.length - 1];\n        args.length -= 1;\n    } else {\n        callback = null;\n    }\n\n    if (args.length === 2 && typeof args[0] === \"string\" && typeof args[1] === \"object\") {\n        // User does: client.hmset(key, {key1: val1, key2: val2})\n        tmp_args = [ args[0] ];\n        tmp_keys = Object.keys(args[1]);\n        for (i = 0, il = tmp_keys.length; i < il ; i++) {\n            key = tmp_keys[i];\n            tmp_args.push(key);\n            tmp_args.push(args[1][key]);\n        }\n        args = tmp_args;\n    }\n\n    return this.send_command(\"hmset\", args, callback);\n};\nRedisClient.prototype.HMSET = RedisClient.prototype.hmset;\n\nMulti.prototype.hmset = function () {\n    var args = to_array(arguments), tmp_args;\n    if (args.length >= 2 && typeof args[0] === \"string\" && typeof args[1] === \"object\") {\n        tmp_args = [ \"hmset\", args[0] ];\n        Object.keys(args[1]).map(function (key) {\n            tmp_args.push(key);\n            tmp_args.push(args[1][key]);\n        });\n        if (args[2]) {\n            tmp_args.push(args[2]);\n        }\n        args = tmp_args;\n    } else {\n        args.unshift(\"hmset\");\n    }\n\n    this.queue.push(args);\n    return this;\n};\nMulti.prototype.HMSET = Multi.prototype.hmset;\n\nMulti.prototype.exec = function (callback) {\n    var self = this;\n\n    // drain queue, callback will catch \"QUEUED\" or error\n    // TODO - get rid of all of these anonymous functions which are elegant but slow\n    this.queue.forEach(function (args, index) {\n        var command = args[0], obj;\n        if (typeof args[args.length - 1] === \"function\") {\n            args = args.slice(1, -1);\n        } else {\n            args = args.slice(1);\n        }\n        if (args.length === 1 && Array.isArray(args[0])) {\n            args = args[0];\n        }\n        if (command === 'hmset' && typeof args[1] === 'object') {\n            obj = args.pop();\n            Object.keys(obj).forEach(function (key) {\n                args.push(key);\n                args.push(obj[key]);\n            });\n        }\n        this.client.send_command(command, args, function (err, reply) {\n            if (err) {\n                var cur = self.queue[index];\n                if (typeof cur[cur.length - 1] === \"function\") {\n                    cur[cur.length - 1](err);\n                } else {\n                    throw new Error(err);\n                }\n                self.queue.splice(index, 1);\n            }\n        });\n    }, this);\n\n    // TODO - make this callback part of Multi.prototype instead of creating it each time\n    return this.client.send_command(\"EXEC\", [], function (err, replies) {\n        if (err) {\n            if (callback) {\n                callback(new Error(err));\n                return;\n            } else {\n                throw new Error(err);\n            }\n        }\n\n        var i, il, j, jl, reply, args;\n\n        if (replies) {\n            for (i = 1, il = self.queue.length; i < il; i += 1) {\n                reply = replies[i - 1];\n                args = self.queue[i];\n\n                // TODO - confusing and error-prone that hgetall is special cased in two places\n                if (reply && args[0].toLowerCase() === \"hgetall\") {\n                    replies[i - 1] = reply = reply_to_object(reply);\n                }\n\n                if (typeof args[args.length - 1] === \"function\") {\n                    args[args.length - 1](null, reply);\n                }\n            }\n        }\n\n        if (callback) {\n            callback(null, replies);\n        }\n    });\n};\nMulti.prototype.EXEC = Multi.prototype.exec;\n\nRedisClient.prototype.multi = function (args) {\n    return new Multi(this, args);\n};\nRedisClient.prototype.MULTI = function (args) {\n    return new Multi(this, args);\n};\n\nexports.createClient = function (port_arg, host_arg, options) {\n    var port = port_arg || default_port,\n        host = host_arg || default_host,\n        redis_client, net_client;\n\n    net_client = net.createConnection(port, host);\n\n    redis_client = new RedisClient(net_client, options);\n\n    redis_client.port = port;\n    redis_client.host = host;\n\n    return redis_client;\n};\n\nexports.print = function (err, reply) {\n    if (err) {\n        console.log(\"Error: \" + err);\n    } else {\n        console.log(\"Reply: \" + reply);\n    }\n};\n"]],"start1":0,"start2":0,"length1":0,"length2":35977}]],"length":35977}
